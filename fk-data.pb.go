// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: fk-data.proto

package fk_data

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type DownloadFlags int32

const (
	DownloadFlags_READING_FLAGS_NONE          DownloadFlags = 0
	DownloadFlags_READING_FLAGS_NOT_RECORDING DownloadFlags = 1
	DownloadFlags_READING_FLAGS_MANUAL        DownloadFlags = 2
)

var DownloadFlags_name = map[int32]string{
	0: "READING_FLAGS_NONE",
	1: "READING_FLAGS_NOT_RECORDING",
	2: "READING_FLAGS_MANUAL",
}

var DownloadFlags_value = map[string]int32{
	"READING_FLAGS_NONE":          0,
	"READING_FLAGS_NOT_RECORDING": 1,
	"READING_FLAGS_MANUAL":        2,
}

func (x DownloadFlags) String() string {
	return proto.EnumName(DownloadFlags_name, int32(x))
}

func (DownloadFlags) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{0}
}

type ConditionFlags int32

const (
	ConditionFlags_CONDITION_FLAGS_NONE      ConditionFlags = 0
	ConditionFlags_CONDITION_FLAGS_RECORDING ConditionFlags = 1
)

var ConditionFlags_name = map[int32]string{
	0: "CONDITION_FLAGS_NONE",
	1: "CONDITION_FLAGS_RECORDING",
}

var ConditionFlags_value = map[string]int32{
	"CONDITION_FLAGS_NONE":      0,
	"CONDITION_FLAGS_RECORDING": 1,
}

func (x ConditionFlags) String() string {
	return proto.EnumName(ConditionFlags_name, int32(x))
}

func (ConditionFlags) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{1}
}

type SignedRecordKind int32

const (
	SignedRecordKind_SIGNED_RECORD_KIND_NONE      SignedRecordKind = 0
	SignedRecordKind_SIGNED_RECORD_KIND_MODULES   SignedRecordKind = 1
	SignedRecordKind_SIGNED_RECORD_KIND_SCHEDULE  SignedRecordKind = 2
	SignedRecordKind_SIGNED_RECORD_KIND_STATE     SignedRecordKind = 3
	SignedRecordKind_SIGNED_RECORD_KIND_RAW_STATE SignedRecordKind = 4
	SignedRecordKind_SIGNED_RECORD_KIND_OTHER     SignedRecordKind = 255
)

var SignedRecordKind_name = map[int32]string{
	0:   "SIGNED_RECORD_KIND_NONE",
	1:   "SIGNED_RECORD_KIND_MODULES",
	2:   "SIGNED_RECORD_KIND_SCHEDULE",
	3:   "SIGNED_RECORD_KIND_STATE",
	4:   "SIGNED_RECORD_KIND_RAW_STATE",
	255: "SIGNED_RECORD_KIND_OTHER",
}

var SignedRecordKind_value = map[string]int32{
	"SIGNED_RECORD_KIND_NONE":      0,
	"SIGNED_RECORD_KIND_MODULES":   1,
	"SIGNED_RECORD_KIND_SCHEDULE":  2,
	"SIGNED_RECORD_KIND_STATE":     3,
	"SIGNED_RECORD_KIND_RAW_STATE": 4,
	"SIGNED_RECORD_KIND_OTHER":     255,
}

func (x SignedRecordKind) String() string {
	return proto.EnumName(SignedRecordKind_name, int32(x))
}

func (SignedRecordKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{2}
}

type DeviceLocation struct {
	Enabled              uint32    `protobuf:"varint,7,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Fix                  uint32    `protobuf:"varint,1,opt,name=fix,proto3" json:"fix,omitempty"`
	Time                 int64     `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	Longitude            float32   `protobuf:"fixed32,3,opt,name=longitude,proto3" json:"longitude,omitempty"`
	Latitude             float32   `protobuf:"fixed32,4,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Altitude             float32   `protobuf:"fixed32,5,opt,name=altitude,proto3" json:"altitude,omitempty"`
	Coordinates          []float32 `protobuf:"fixed32,6,rep,packed,name=coordinates,proto3" json:"coordinates,omitempty"`
	Satellites           uint32    `protobuf:"varint,8,opt,name=satellites,proto3" json:"satellites,omitempty"`
	Hdop                 uint32    `protobuf:"varint,9,opt,name=hdop,proto3" json:"hdop,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *DeviceLocation) Reset()         { *m = DeviceLocation{} }
func (m *DeviceLocation) String() string { return proto.CompactTextString(m) }
func (*DeviceLocation) ProtoMessage()    {}
func (*DeviceLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{0}
}
func (m *DeviceLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceLocation.Merge(m, src)
}
func (m *DeviceLocation) XXX_Size() int {
	return m.Size()
}
func (m *DeviceLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceLocation.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceLocation proto.InternalMessageInfo

func (m *DeviceLocation) GetEnabled() uint32 {
	if m != nil {
		return m.Enabled
	}
	return 0
}

func (m *DeviceLocation) GetFix() uint32 {
	if m != nil {
		return m.Fix
	}
	return 0
}

func (m *DeviceLocation) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *DeviceLocation) GetLongitude() float32 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *DeviceLocation) GetLatitude() float32 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *DeviceLocation) GetAltitude() float32 {
	if m != nil {
		return m.Altitude
	}
	return 0
}

func (m *DeviceLocation) GetCoordinates() []float32 {
	if m != nil {
		return m.Coordinates
	}
	return nil
}

func (m *DeviceLocation) GetSatellites() uint32 {
	if m != nil {
		return m.Satellites
	}
	return 0
}

func (m *DeviceLocation) GetHdop() uint32 {
	if m != nil {
		return m.Hdop
	}
	return 0
}

type SensorReading struct {
	Reading              uint64   `protobuf:"varint,1,opt,name=reading,proto3" json:"reading,omitempty"`
	Time                 int64    `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	Sensor               uint32   `protobuf:"varint,3,opt,name=sensor,proto3" json:"sensor,omitempty"`
	Value                float32  `protobuf:"fixed32,4,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SensorReading) Reset()         { *m = SensorReading{} }
func (m *SensorReading) String() string { return proto.CompactTextString(m) }
func (*SensorReading) ProtoMessage()    {}
func (*SensorReading) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{1}
}
func (m *SensorReading) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SensorReading) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SensorReading.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SensorReading) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SensorReading.Merge(m, src)
}
func (m *SensorReading) XXX_Size() int {
	return m.Size()
}
func (m *SensorReading) XXX_DiscardUnknown() {
	xxx_messageInfo_SensorReading.DiscardUnknown(m)
}

var xxx_messageInfo_SensorReading proto.InternalMessageInfo

func (m *SensorReading) GetReading() uint64 {
	if m != nil {
		return m.Reading
	}
	return 0
}

func (m *SensorReading) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *SensorReading) GetSensor() uint32 {
	if m != nil {
		return m.Sensor
	}
	return 0
}

func (m *SensorReading) GetValue() float32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type LoggedReading struct {
	Version              uint32          `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	Location             *DeviceLocation `protobuf:"bytes,2,opt,name=location,proto3" json:"location,omitempty"`
	Reading              *SensorReading  `protobuf:"bytes,3,opt,name=reading,proto3" json:"reading,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *LoggedReading) Reset()         { *m = LoggedReading{} }
func (m *LoggedReading) String() string { return proto.CompactTextString(m) }
func (*LoggedReading) ProtoMessage()    {}
func (*LoggedReading) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{2}
}
func (m *LoggedReading) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoggedReading) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoggedReading.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoggedReading) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoggedReading.Merge(m, src)
}
func (m *LoggedReading) XXX_Size() int {
	return m.Size()
}
func (m *LoggedReading) XXX_DiscardUnknown() {
	xxx_messageInfo_LoggedReading.DiscardUnknown(m)
}

var xxx_messageInfo_LoggedReading proto.InternalMessageInfo

func (m *LoggedReading) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *LoggedReading) GetLocation() *DeviceLocation {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *LoggedReading) GetReading() *SensorReading {
	if m != nil {
		return m.Reading
	}
	return nil
}

type SensorAndValue struct {
	Sensor               uint32   `protobuf:"varint,1,opt,name=sensor,proto3" json:"sensor,omitempty"`
	Value                float32  `protobuf:"fixed32,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SensorAndValue) Reset()         { *m = SensorAndValue{} }
func (m *SensorAndValue) String() string { return proto.CompactTextString(m) }
func (*SensorAndValue) ProtoMessage()    {}
func (*SensorAndValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{3}
}
func (m *SensorAndValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SensorAndValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SensorAndValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SensorAndValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SensorAndValue.Merge(m, src)
}
func (m *SensorAndValue) XXX_Size() int {
	return m.Size()
}
func (m *SensorAndValue) XXX_DiscardUnknown() {
	xxx_messageInfo_SensorAndValue.DiscardUnknown(m)
}

var xxx_messageInfo_SensorAndValue proto.InternalMessageInfo

func (m *SensorAndValue) GetSensor() uint32 {
	if m != nil {
		return m.Sensor
	}
	return 0
}

func (m *SensorAndValue) GetValue() float32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type ModuleHeader struct {
	Manufacturer         uint32   `protobuf:"varint,1,opt,name=manufacturer,proto3" json:"manufacturer,omitempty"`
	Kind                 uint32   `protobuf:"varint,2,opt,name=kind,proto3" json:"kind,omitempty"`
	Version              uint32   `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ModuleHeader) Reset()         { *m = ModuleHeader{} }
func (m *ModuleHeader) String() string { return proto.CompactTextString(m) }
func (*ModuleHeader) ProtoMessage()    {}
func (*ModuleHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{4}
}
func (m *ModuleHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModuleHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleHeader.Merge(m, src)
}
func (m *ModuleHeader) XXX_Size() int {
	return m.Size()
}
func (m *ModuleHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleHeader proto.InternalMessageInfo

func (m *ModuleHeader) GetManufacturer() uint32 {
	if m != nil {
		return m.Manufacturer
	}
	return 0
}

func (m *ModuleHeader) GetKind() uint32 {
	if m != nil {
		return m.Kind
	}
	return 0
}

func (m *ModuleHeader) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

type ModuleInfo struct {
	Position             uint32        `protobuf:"varint,1,opt,name=position,proto3" json:"position,omitempty"`
	Address              uint32        `protobuf:"varint,2,opt,name=address,proto3" json:"address,omitempty"`
	Name                 string        `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Header               *ModuleHeader `protobuf:"bytes,4,opt,name=header,proto3" json:"header,omitempty"`
	Firmware             *Firmware     `protobuf:"bytes,5,opt,name=firmware,proto3" json:"firmware,omitempty"`
	Sensors              []*SensorInfo `protobuf:"bytes,6,rep,name=sensors,proto3" json:"sensors,omitempty"`
	Id                   []byte        `protobuf:"bytes,7,opt,name=id,proto3" json:"id,omitempty"`
	Flags                uint32        `protobuf:"varint,8,opt,name=flags,proto3" json:"flags,omitempty"`
	Status               []byte        `protobuf:"bytes,9,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ModuleInfo) Reset()         { *m = ModuleInfo{} }
func (m *ModuleInfo) String() string { return proto.CompactTextString(m) }
func (*ModuleInfo) ProtoMessage()    {}
func (*ModuleInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{5}
}
func (m *ModuleInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModuleInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleInfo.Merge(m, src)
}
func (m *ModuleInfo) XXX_Size() int {
	return m.Size()
}
func (m *ModuleInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleInfo proto.InternalMessageInfo

func (m *ModuleInfo) GetPosition() uint32 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *ModuleInfo) GetAddress() uint32 {
	if m != nil {
		return m.Address
	}
	return 0
}

func (m *ModuleInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ModuleInfo) GetHeader() *ModuleHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *ModuleInfo) GetFirmware() *Firmware {
	if m != nil {
		return m.Firmware
	}
	return nil
}

func (m *ModuleInfo) GetSensors() []*SensorInfo {
	if m != nil {
		return m.Sensors
	}
	return nil
}

func (m *ModuleInfo) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *ModuleInfo) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *ModuleInfo) GetStatus() []byte {
	if m != nil {
		return m.Status
	}
	return nil
}

type SensorInfo struct {
	Number               uint32   `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	UnitOfMeasure        string   `protobuf:"bytes,3,opt,name=unitOfMeasure,proto3" json:"unitOfMeasure,omitempty"`
	Flags                uint32   `protobuf:"varint,4,opt,name=flags,proto3" json:"flags,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SensorInfo) Reset()         { *m = SensorInfo{} }
func (m *SensorInfo) String() string { return proto.CompactTextString(m) }
func (*SensorInfo) ProtoMessage()    {}
func (*SensorInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{6}
}
func (m *SensorInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SensorInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SensorInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SensorInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SensorInfo.Merge(m, src)
}
func (m *SensorInfo) XXX_Size() int {
	return m.Size()
}
func (m *SensorInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SensorInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SensorInfo proto.InternalMessageInfo

func (m *SensorInfo) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *SensorInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SensorInfo) GetUnitOfMeasure() string {
	if m != nil {
		return m.UnitOfMeasure
	}
	return ""
}

func (m *SensorInfo) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

type Firmware struct {
	Version              string   `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	Build                string   `protobuf:"bytes,2,opt,name=build,proto3" json:"build,omitempty"`
	Number               string   `protobuf:"bytes,3,opt,name=number,proto3" json:"number,omitempty"`
	Timestamp            uint64   `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Hash                 string   `protobuf:"bytes,5,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Firmware) Reset()         { *m = Firmware{} }
func (m *Firmware) String() string { return proto.CompactTextString(m) }
func (*Firmware) ProtoMessage()    {}
func (*Firmware) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{7}
}
func (m *Firmware) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Firmware) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Firmware.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Firmware) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Firmware.Merge(m, src)
}
func (m *Firmware) XXX_Size() int {
	return m.Size()
}
func (m *Firmware) XXX_DiscardUnknown() {
	xxx_messageInfo_Firmware.DiscardUnknown(m)
}

var xxx_messageInfo_Firmware proto.InternalMessageInfo

func (m *Firmware) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Firmware) GetBuild() string {
	if m != nil {
		return m.Build
	}
	return ""
}

func (m *Firmware) GetNumber() string {
	if m != nil {
		return m.Number
	}
	return ""
}

func (m *Firmware) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Firmware) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

type Metadata struct {
	DeviceId             []byte        `protobuf:"bytes,1,opt,name=deviceId,proto3" json:"deviceId,omitempty"`
	Time                 int64         `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	Git                  string        `protobuf:"bytes,3,opt,name=git,proto3" json:"git,omitempty"`
	Build                string        `protobuf:"bytes,7,opt,name=build,proto3" json:"build,omitempty"`
	ResetCause           uint32        `protobuf:"varint,4,opt,name=resetCause,proto3" json:"resetCause,omitempty"`
	Sensors              []*SensorInfo `protobuf:"bytes,5,rep,name=sensors,proto3" json:"sensors,omitempty"`
	Modules              []*ModuleInfo `protobuf:"bytes,6,rep,name=modules,proto3" json:"modules,omitempty"`
	Firmware             *Firmware     `protobuf:"bytes,8,opt,name=firmware,proto3" json:"firmware,omitempty"`
	Generation           []byte        `protobuf:"bytes,9,opt,name=generation,proto3" json:"generation,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Metadata) Reset()         { *m = Metadata{} }
func (m *Metadata) String() string { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()    {}
func (*Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{8}
}
func (m *Metadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata.Merge(m, src)
}
func (m *Metadata) XXX_Size() int {
	return m.Size()
}
func (m *Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata proto.InternalMessageInfo

func (m *Metadata) GetDeviceId() []byte {
	if m != nil {
		return m.DeviceId
	}
	return nil
}

func (m *Metadata) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *Metadata) GetGit() string {
	if m != nil {
		return m.Git
	}
	return ""
}

func (m *Metadata) GetBuild() string {
	if m != nil {
		return m.Build
	}
	return ""
}

func (m *Metadata) GetResetCause() uint32 {
	if m != nil {
		return m.ResetCause
	}
	return 0
}

func (m *Metadata) GetSensors() []*SensorInfo {
	if m != nil {
		return m.Sensors
	}
	return nil
}

func (m *Metadata) GetModules() []*ModuleInfo {
	if m != nil {
		return m.Modules
	}
	return nil
}

func (m *Metadata) GetFirmware() *Firmware {
	if m != nil {
		return m.Firmware
	}
	return nil
}

func (m *Metadata) GetGeneration() []byte {
	if m != nil {
		return m.Generation
	}
	return nil
}

type Status struct {
	Time                 int64    `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	Uptime               uint32   `protobuf:"varint,2,opt,name=uptime,proto3" json:"uptime,omitempty"`
	Battery              float32  `protobuf:"fixed32,3,opt,name=battery,proto3" json:"battery,omitempty"`
	Memory               uint32   `protobuf:"varint,4,opt,name=memory,proto3" json:"memory,omitempty"`
	Busy                 uint64   `protobuf:"varint,5,opt,name=busy,proto3" json:"busy,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Status) Reset()         { *m = Status{} }
func (m *Status) String() string { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()    {}
func (*Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{9}
}
func (m *Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status.Merge(m, src)
}
func (m *Status) XXX_Size() int {
	return m.Size()
}
func (m *Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Status proto.InternalMessageInfo

func (m *Status) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *Status) GetUptime() uint32 {
	if m != nil {
		return m.Uptime
	}
	return 0
}

func (m *Status) GetBattery() float32 {
	if m != nil {
		return m.Battery
	}
	return 0
}

func (m *Status) GetMemory() uint32 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *Status) GetBusy() uint64 {
	if m != nil {
		return m.Busy
	}
	return 0
}

type LogMessage struct {
	Time                 int64    `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	Uptime               uint32   `protobuf:"varint,2,opt,name=uptime,proto3" json:"uptime,omitempty"`
	Level                uint32   `protobuf:"varint,3,opt,name=level,proto3" json:"level,omitempty"`
	Facility             string   `protobuf:"bytes,4,opt,name=facility,proto3" json:"facility,omitempty"`
	Message              string   `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LogMessage) Reset()         { *m = LogMessage{} }
func (m *LogMessage) String() string { return proto.CompactTextString(m) }
func (*LogMessage) ProtoMessage()    {}
func (*LogMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{10}
}
func (m *LogMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogMessage.Merge(m, src)
}
func (m *LogMessage) XXX_Size() int {
	return m.Size()
}
func (m *LogMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_LogMessage.DiscardUnknown(m)
}

var xxx_messageInfo_LogMessage proto.InternalMessageInfo

func (m *LogMessage) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *LogMessage) GetUptime() uint32 {
	if m != nil {
		return m.Uptime
	}
	return 0
}

func (m *LogMessage) GetLevel() uint32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *LogMessage) GetFacility() string {
	if m != nil {
		return m.Facility
	}
	return ""
}

func (m *LogMessage) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type SensorGroup struct {
	Module               uint32            `protobuf:"varint,1,opt,name=module,proto3" json:"module,omitempty"`
	Readings             []*SensorAndValue `protobuf:"bytes,2,rep,name=readings,proto3" json:"readings,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *SensorGroup) Reset()         { *m = SensorGroup{} }
func (m *SensorGroup) String() string { return proto.CompactTextString(m) }
func (*SensorGroup) ProtoMessage()    {}
func (*SensorGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{11}
}
func (m *SensorGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SensorGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SensorGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SensorGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SensorGroup.Merge(m, src)
}
func (m *SensorGroup) XXX_Size() int {
	return m.Size()
}
func (m *SensorGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_SensorGroup.DiscardUnknown(m)
}

var xxx_messageInfo_SensorGroup proto.InternalMessageInfo

func (m *SensorGroup) GetModule() uint32 {
	if m != nil {
		return m.Module
	}
	return 0
}

func (m *SensorGroup) GetReadings() []*SensorAndValue {
	if m != nil {
		return m.Readings
	}
	return nil
}

type Readings struct {
	Time                 int64           `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	Reading              uint64          `protobuf:"varint,2,opt,name=reading,proto3" json:"reading,omitempty"`
	Flags                uint32          `protobuf:"varint,3,opt,name=flags,proto3" json:"flags,omitempty"`
	Meta                 uint64          `protobuf:"varint,6,opt,name=meta,proto3" json:"meta,omitempty"`
	Uptime               uint32          `protobuf:"varint,7,opt,name=uptime,proto3" json:"uptime,omitempty"`
	Location             *DeviceLocation `protobuf:"bytes,4,opt,name=location,proto3" json:"location,omitempty"`
	SensorGroups         []*SensorGroup  `protobuf:"bytes,5,rep,name=sensorGroups,proto3" json:"sensorGroups,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Readings) Reset()         { *m = Readings{} }
func (m *Readings) String() string { return proto.CompactTextString(m) }
func (*Readings) ProtoMessage()    {}
func (*Readings) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{12}
}
func (m *Readings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Readings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Readings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Readings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Readings.Merge(m, src)
}
func (m *Readings) XXX_Size() int {
	return m.Size()
}
func (m *Readings) XXX_DiscardUnknown() {
	xxx_messageInfo_Readings.DiscardUnknown(m)
}

var xxx_messageInfo_Readings proto.InternalMessageInfo

func (m *Readings) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *Readings) GetReading() uint64 {
	if m != nil {
		return m.Reading
	}
	return 0
}

func (m *Readings) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *Readings) GetMeta() uint64 {
	if m != nil {
		return m.Meta
	}
	return 0
}

func (m *Readings) GetUptime() uint32 {
	if m != nil {
		return m.Uptime
	}
	return 0
}

func (m *Readings) GetLocation() *DeviceLocation {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Readings) GetSensorGroups() []*SensorGroup {
	if m != nil {
		return m.SensorGroups
	}
	return nil
}

type Interval struct {
	Start                uint64   `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End                  uint64   `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	Interval             uint32   `protobuf:"varint,3,opt,name=interval,proto3" json:"interval,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Interval) Reset()         { *m = Interval{} }
func (m *Interval) String() string { return proto.CompactTextString(m) }
func (*Interval) ProtoMessage()    {}
func (*Interval) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{13}
}
func (m *Interval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Interval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Interval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Interval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Interval.Merge(m, src)
}
func (m *Interval) XXX_Size() int {
	return m.Size()
}
func (m *Interval) XXX_DiscardUnknown() {
	xxx_messageInfo_Interval.DiscardUnknown(m)
}

var xxx_messageInfo_Interval proto.InternalMessageInfo

func (m *Interval) GetStart() uint64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Interval) GetEnd() uint64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *Interval) GetInterval() uint32 {
	if m != nil {
		return m.Interval
	}
	return 0
}

type JobSchedule struct {
	Cron                 []byte      `protobuf:"bytes,1,opt,name=cron,proto3" json:"cron,omitempty"`
	Interval             uint32      `protobuf:"varint,2,opt,name=interval,proto3" json:"interval,omitempty"`
	Repeated             uint32      `protobuf:"varint,3,opt,name=repeated,proto3" json:"repeated,omitempty"`
	Duration             uint32      `protobuf:"varint,4,opt,name=duration,proto3" json:"duration,omitempty"`
	Jitter               uint32      `protobuf:"varint,5,opt,name=jitter,proto3" json:"jitter,omitempty"`
	Intervals            []*Interval `protobuf:"bytes,6,rep,name=intervals,proto3" json:"intervals,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *JobSchedule) Reset()         { *m = JobSchedule{} }
func (m *JobSchedule) String() string { return proto.CompactTextString(m) }
func (*JobSchedule) ProtoMessage()    {}
func (*JobSchedule) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{14}
}
func (m *JobSchedule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobSchedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobSchedule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobSchedule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobSchedule.Merge(m, src)
}
func (m *JobSchedule) XXX_Size() int {
	return m.Size()
}
func (m *JobSchedule) XXX_DiscardUnknown() {
	xxx_messageInfo_JobSchedule.DiscardUnknown(m)
}

var xxx_messageInfo_JobSchedule proto.InternalMessageInfo

func (m *JobSchedule) GetCron() []byte {
	if m != nil {
		return m.Cron
	}
	return nil
}

func (m *JobSchedule) GetInterval() uint32 {
	if m != nil {
		return m.Interval
	}
	return 0
}

func (m *JobSchedule) GetRepeated() uint32 {
	if m != nil {
		return m.Repeated
	}
	return 0
}

func (m *JobSchedule) GetDuration() uint32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *JobSchedule) GetJitter() uint32 {
	if m != nil {
		return m.Jitter
	}
	return 0
}

func (m *JobSchedule) GetIntervals() []*Interval {
	if m != nil {
		return m.Intervals
	}
	return nil
}

type Schedule struct {
	Readings             *JobSchedule `protobuf:"bytes,1,opt,name=readings,proto3" json:"readings,omitempty"`
	Network              *JobSchedule `protobuf:"bytes,2,opt,name=network,proto3" json:"network,omitempty"`
	Lora                 *JobSchedule `protobuf:"bytes,3,opt,name=lora,proto3" json:"lora,omitempty"`
	Gps                  *JobSchedule `protobuf:"bytes,4,opt,name=gps,proto3" json:"gps,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Schedule) Reset()         { *m = Schedule{} }
func (m *Schedule) String() string { return proto.CompactTextString(m) }
func (*Schedule) ProtoMessage()    {}
func (*Schedule) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{15}
}
func (m *Schedule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Schedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Schedule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Schedule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schedule.Merge(m, src)
}
func (m *Schedule) XXX_Size() int {
	return m.Size()
}
func (m *Schedule) XXX_DiscardUnknown() {
	xxx_messageInfo_Schedule.DiscardUnknown(m)
}

var xxx_messageInfo_Schedule proto.InternalMessageInfo

func (m *Schedule) GetReadings() *JobSchedule {
	if m != nil {
		return m.Readings
	}
	return nil
}

func (m *Schedule) GetNetwork() *JobSchedule {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *Schedule) GetLora() *JobSchedule {
	if m != nil {
		return m.Lora
	}
	return nil
}

func (m *Schedule) GetGps() *JobSchedule {
	if m != nil {
		return m.Gps
	}
	return nil
}

type Identity struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Identity) Reset()         { *m = Identity{} }
func (m *Identity) String() string { return proto.CompactTextString(m) }
func (*Identity) ProtoMessage()    {}
func (*Identity) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{16}
}
func (m *Identity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Identity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Identity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Identity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Identity.Merge(m, src)
}
func (m *Identity) XXX_Size() int {
	return m.Size()
}
func (m *Identity) XXX_DiscardUnknown() {
	xxx_messageInfo_Identity.DiscardUnknown(m)
}

var xxx_messageInfo_Identity proto.InternalMessageInfo

func (m *Identity) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Condition struct {
	Flags                uint32   `protobuf:"varint,1,opt,name=flags,proto3" json:"flags,omitempty"`
	Recording            uint32   `protobuf:"varint,2,opt,name=recording,proto3" json:"recording,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Condition) Reset()         { *m = Condition{} }
func (m *Condition) String() string { return proto.CompactTextString(m) }
func (*Condition) ProtoMessage()    {}
func (*Condition) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{17}
}
func (m *Condition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Condition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Condition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Condition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Condition.Merge(m, src)
}
func (m *Condition) XXX_Size() int {
	return m.Size()
}
func (m *Condition) XXX_DiscardUnknown() {
	xxx_messageInfo_Condition.DiscardUnknown(m)
}

var xxx_messageInfo_Condition proto.InternalMessageInfo

func (m *Condition) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *Condition) GetRecording() uint32 {
	if m != nil {
		return m.Recording
	}
	return 0
}

type NetworkInfo struct {
	Ssid                 string   `protobuf:"bytes,1,opt,name=ssid,proto3" json:"ssid,omitempty"`
	Password             string   `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	Create               bool     `protobuf:"varint,3,opt,name=create,proto3" json:"create,omitempty"`
	Preferred            bool     `protobuf:"varint,4,opt,name=preferred,proto3" json:"preferred,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkInfo) Reset()         { *m = NetworkInfo{} }
func (m *NetworkInfo) String() string { return proto.CompactTextString(m) }
func (*NetworkInfo) ProtoMessage()    {}
func (*NetworkInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{18}
}
func (m *NetworkInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkInfo.Merge(m, src)
}
func (m *NetworkInfo) XXX_Size() int {
	return m.Size()
}
func (m *NetworkInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkInfo proto.InternalMessageInfo

func (m *NetworkInfo) GetSsid() string {
	if m != nil {
		return m.Ssid
	}
	return ""
}

func (m *NetworkInfo) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *NetworkInfo) GetCreate() bool {
	if m != nil {
		return m.Create
	}
	return false
}

func (m *NetworkInfo) GetPreferred() bool {
	if m != nil {
		return m.Preferred
	}
	return false
}

type WifiTransmission struct {
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	Enabled              bool     `protobuf:"varint,3,opt,name=enabled,proto3" json:"enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WifiTransmission) Reset()         { *m = WifiTransmission{} }
func (m *WifiTransmission) String() string { return proto.CompactTextString(m) }
func (*WifiTransmission) ProtoMessage()    {}
func (*WifiTransmission) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{19}
}
func (m *WifiTransmission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WifiTransmission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WifiTransmission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WifiTransmission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WifiTransmission.Merge(m, src)
}
func (m *WifiTransmission) XXX_Size() int {
	return m.Size()
}
func (m *WifiTransmission) XXX_DiscardUnknown() {
	xxx_messageInfo_WifiTransmission.DiscardUnknown(m)
}

var xxx_messageInfo_WifiTransmission proto.InternalMessageInfo

func (m *WifiTransmission) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *WifiTransmission) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *WifiTransmission) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

type TransmissionSettings struct {
	Wifi                 *WifiTransmission `protobuf:"bytes,1,opt,name=wifi,proto3" json:"wifi,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TransmissionSettings) Reset()         { *m = TransmissionSettings{} }
func (m *TransmissionSettings) String() string { return proto.CompactTextString(m) }
func (*TransmissionSettings) ProtoMessage()    {}
func (*TransmissionSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{20}
}
func (m *TransmissionSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransmissionSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransmissionSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransmissionSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransmissionSettings.Merge(m, src)
}
func (m *TransmissionSettings) XXX_Size() int {
	return m.Size()
}
func (m *TransmissionSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_TransmissionSettings.DiscardUnknown(m)
}

var xxx_messageInfo_TransmissionSettings proto.InternalMessageInfo

func (m *TransmissionSettings) GetWifi() *WifiTransmission {
	if m != nil {
		return m.Wifi
	}
	return nil
}

type NetworkSettings struct {
	Networks             []*NetworkInfo `protobuf:"bytes,1,rep,name=networks,proto3" json:"networks,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *NetworkSettings) Reset()         { *m = NetworkSettings{} }
func (m *NetworkSettings) String() string { return proto.CompactTextString(m) }
func (*NetworkSettings) ProtoMessage()    {}
func (*NetworkSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{21}
}
func (m *NetworkSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkSettings.Merge(m, src)
}
func (m *NetworkSettings) XXX_Size() int {
	return m.Size()
}
func (m *NetworkSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkSettings.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkSettings proto.InternalMessageInfo

func (m *NetworkSettings) GetNetworks() []*NetworkInfo {
	if m != nil {
		return m.Networks
	}
	return nil
}

type LoraSettings struct {
	DeviceEui            []byte   `protobuf:"bytes,1,opt,name=deviceEui,proto3" json:"deviceEui,omitempty"`
	AppKey               []byte   `protobuf:"bytes,2,opt,name=appKey,proto3" json:"appKey,omitempty"`
	AppEui               []byte   `protobuf:"bytes,3,opt,name=appEui,proto3" json:"appEui,omitempty"`
	FrequencyBand        uint32   `protobuf:"varint,4,opt,name=frequencyBand,proto3" json:"frequencyBand,omitempty"`
	DeviceAddress        []byte   `protobuf:"bytes,5,opt,name=deviceAddress,proto3" json:"deviceAddress,omitempty"`
	NetworkSessionKey    []byte   `protobuf:"bytes,6,opt,name=networkSessionKey,proto3" json:"networkSessionKey,omitempty"`
	AppSessionKey        []byte   `protobuf:"bytes,7,opt,name=appSessionKey,proto3" json:"appSessionKey,omitempty"`
	UplinkCounter        uint32   `protobuf:"varint,8,opt,name=uplinkCounter,proto3" json:"uplinkCounter,omitempty"`
	DownlinkCounter      uint32   `protobuf:"varint,9,opt,name=downlinkCounter,proto3" json:"downlinkCounter,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoraSettings) Reset()         { *m = LoraSettings{} }
func (m *LoraSettings) String() string { return proto.CompactTextString(m) }
func (*LoraSettings) ProtoMessage()    {}
func (*LoraSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{22}
}
func (m *LoraSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoraSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoraSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoraSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoraSettings.Merge(m, src)
}
func (m *LoraSettings) XXX_Size() int {
	return m.Size()
}
func (m *LoraSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_LoraSettings.DiscardUnknown(m)
}

var xxx_messageInfo_LoraSettings proto.InternalMessageInfo

func (m *LoraSettings) GetDeviceEui() []byte {
	if m != nil {
		return m.DeviceEui
	}
	return nil
}

func (m *LoraSettings) GetAppKey() []byte {
	if m != nil {
		return m.AppKey
	}
	return nil
}

func (m *LoraSettings) GetAppEui() []byte {
	if m != nil {
		return m.AppEui
	}
	return nil
}

func (m *LoraSettings) GetFrequencyBand() uint32 {
	if m != nil {
		return m.FrequencyBand
	}
	return 0
}

func (m *LoraSettings) GetDeviceAddress() []byte {
	if m != nil {
		return m.DeviceAddress
	}
	return nil
}

func (m *LoraSettings) GetNetworkSessionKey() []byte {
	if m != nil {
		return m.NetworkSessionKey
	}
	return nil
}

func (m *LoraSettings) GetAppSessionKey() []byte {
	if m != nil {
		return m.AppSessionKey
	}
	return nil
}

func (m *LoraSettings) GetUplinkCounter() uint32 {
	if m != nil {
		return m.UplinkCounter
	}
	return 0
}

func (m *LoraSettings) GetDownlinkCounter() uint32 {
	if m != nil {
		return m.DownlinkCounter
	}
	return 0
}

//*
// I may break this into a MetaRecord.
type DataRecord struct {
	LoggedReading        *LoggedReading        `protobuf:"bytes,1,opt,name=loggedReading,proto3" json:"loggedReading,omitempty"`
	Metadata             *Metadata             `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Log                  *LogMessage           `protobuf:"bytes,3,opt,name=log,proto3" json:"log,omitempty"`
	Logs                 []*LogMessage         `protobuf:"bytes,13,rep,name=logs,proto3" json:"logs,omitempty"`
	Status               *Status               `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`
	Readings             *Readings             `protobuf:"bytes,5,opt,name=readings,proto3" json:"readings,omitempty"`
	Modules              []*ModuleInfo         `protobuf:"bytes,6,rep,name=modules,proto3" json:"modules,omitempty"`
	Schedule             *Schedule             `protobuf:"bytes,7,opt,name=schedule,proto3" json:"schedule,omitempty"`
	Meta                 uint64                `protobuf:"varint,8,opt,name=meta,proto3" json:"meta,omitempty"`
	Identity             *Identity             `protobuf:"bytes,9,opt,name=identity,proto3" json:"identity,omitempty"`
	Condition            *Condition            `protobuf:"bytes,10,opt,name=condition,proto3" json:"condition,omitempty"`
	Lora                 *LoraSettings         `protobuf:"bytes,11,opt,name=lora,proto3" json:"lora,omitempty"`
	Network              *NetworkSettings      `protobuf:"bytes,12,opt,name=network,proto3" json:"network,omitempty"`
	Transmission         *TransmissionSettings `protobuf:"bytes,14,opt,name=transmission,proto3" json:"transmission,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *DataRecord) Reset()         { *m = DataRecord{} }
func (m *DataRecord) String() string { return proto.CompactTextString(m) }
func (*DataRecord) ProtoMessage()    {}
func (*DataRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{23}
}
func (m *DataRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataRecord.Merge(m, src)
}
func (m *DataRecord) XXX_Size() int {
	return m.Size()
}
func (m *DataRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_DataRecord.DiscardUnknown(m)
}

var xxx_messageInfo_DataRecord proto.InternalMessageInfo

func (m *DataRecord) GetLoggedReading() *LoggedReading {
	if m != nil {
		return m.LoggedReading
	}
	return nil
}

func (m *DataRecord) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *DataRecord) GetLog() *LogMessage {
	if m != nil {
		return m.Log
	}
	return nil
}

func (m *DataRecord) GetLogs() []*LogMessage {
	if m != nil {
		return m.Logs
	}
	return nil
}

func (m *DataRecord) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *DataRecord) GetReadings() *Readings {
	if m != nil {
		return m.Readings
	}
	return nil
}

func (m *DataRecord) GetModules() []*ModuleInfo {
	if m != nil {
		return m.Modules
	}
	return nil
}

func (m *DataRecord) GetSchedule() *Schedule {
	if m != nil {
		return m.Schedule
	}
	return nil
}

func (m *DataRecord) GetMeta() uint64 {
	if m != nil {
		return m.Meta
	}
	return 0
}

func (m *DataRecord) GetIdentity() *Identity {
	if m != nil {
		return m.Identity
	}
	return nil
}

func (m *DataRecord) GetCondition() *Condition {
	if m != nil {
		return m.Condition
	}
	return nil
}

func (m *DataRecord) GetLora() *LoraSettings {
	if m != nil {
		return m.Lora
	}
	return nil
}

func (m *DataRecord) GetNetwork() *NetworkSettings {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *DataRecord) GetTransmission() *TransmissionSettings {
	if m != nil {
		return m.Transmission
	}
	return nil
}

type SignedRecord struct {
	Kind                 SignedRecordKind `protobuf:"varint,1,opt,name=kind,proto3,enum=fk_data.SignedRecordKind" json:"kind,omitempty"`
	Time                 int64            `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	Data                 []byte           `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	Hash                 []byte           `protobuf:"bytes,4,opt,name=hash,proto3" json:"hash,omitempty"`
	Record               uint64           `protobuf:"varint,5,opt,name=record,proto3" json:"record,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SignedRecord) Reset()         { *m = SignedRecord{} }
func (m *SignedRecord) String() string { return proto.CompactTextString(m) }
func (*SignedRecord) ProtoMessage()    {}
func (*SignedRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{24}
}
func (m *SignedRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignedRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignedRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignedRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedRecord.Merge(m, src)
}
func (m *SignedRecord) XXX_Size() int {
	return m.Size()
}
func (m *SignedRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedRecord.DiscardUnknown(m)
}

var xxx_messageInfo_SignedRecord proto.InternalMessageInfo

func (m *SignedRecord) GetKind() SignedRecordKind {
	if m != nil {
		return m.Kind
	}
	return SignedRecordKind_SIGNED_RECORD_KIND_NONE
}

func (m *SignedRecord) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *SignedRecord) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *SignedRecord) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *SignedRecord) GetRecord() uint64 {
	if m != nil {
		return m.Record
	}
	return 0
}

type LoraRecord struct {
	DeviceId             []byte    `protobuf:"bytes,1,opt,name=deviceId,proto3" json:"deviceId,omitempty"`
	Time                 int64     `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	Number               uint64    `protobuf:"varint,3,opt,name=number,proto3" json:"number,omitempty"`
	Module               uint32    `protobuf:"varint,4,opt,name=module,proto3" json:"module,omitempty"`
	Sensor               uint64    `protobuf:"varint,5,opt,name=sensor,proto3" json:"sensor,omitempty"`
	Values               []float32 `protobuf:"fixed32,6,rep,packed,name=values,proto3" json:"values,omitempty"`
	Data                 []byte    `protobuf:"bytes,7,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *LoraRecord) Reset()         { *m = LoraRecord{} }
func (m *LoraRecord) String() string { return proto.CompactTextString(m) }
func (*LoraRecord) ProtoMessage()    {}
func (*LoraRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_412c2faa5b3d2004, []int{25}
}
func (m *LoraRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoraRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoraRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoraRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoraRecord.Merge(m, src)
}
func (m *LoraRecord) XXX_Size() int {
	return m.Size()
}
func (m *LoraRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_LoraRecord.DiscardUnknown(m)
}

var xxx_messageInfo_LoraRecord proto.InternalMessageInfo

func (m *LoraRecord) GetDeviceId() []byte {
	if m != nil {
		return m.DeviceId
	}
	return nil
}

func (m *LoraRecord) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *LoraRecord) GetNumber() uint64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *LoraRecord) GetModule() uint32 {
	if m != nil {
		return m.Module
	}
	return 0
}

func (m *LoraRecord) GetSensor() uint64 {
	if m != nil {
		return m.Sensor
	}
	return 0
}

func (m *LoraRecord) GetValues() []float32 {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *LoraRecord) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterEnum("fk_data.DownloadFlags", DownloadFlags_name, DownloadFlags_value)
	proto.RegisterEnum("fk_data.ConditionFlags", ConditionFlags_name, ConditionFlags_value)
	proto.RegisterEnum("fk_data.SignedRecordKind", SignedRecordKind_name, SignedRecordKind_value)
	proto.RegisterType((*DeviceLocation)(nil), "fk_data.DeviceLocation")
	proto.RegisterType((*SensorReading)(nil), "fk_data.SensorReading")
	proto.RegisterType((*LoggedReading)(nil), "fk_data.LoggedReading")
	proto.RegisterType((*SensorAndValue)(nil), "fk_data.SensorAndValue")
	proto.RegisterType((*ModuleHeader)(nil), "fk_data.ModuleHeader")
	proto.RegisterType((*ModuleInfo)(nil), "fk_data.ModuleInfo")
	proto.RegisterType((*SensorInfo)(nil), "fk_data.SensorInfo")
	proto.RegisterType((*Firmware)(nil), "fk_data.Firmware")
	proto.RegisterType((*Metadata)(nil), "fk_data.Metadata")
	proto.RegisterType((*Status)(nil), "fk_data.Status")
	proto.RegisterType((*LogMessage)(nil), "fk_data.LogMessage")
	proto.RegisterType((*SensorGroup)(nil), "fk_data.SensorGroup")
	proto.RegisterType((*Readings)(nil), "fk_data.Readings")
	proto.RegisterType((*Interval)(nil), "fk_data.Interval")
	proto.RegisterType((*JobSchedule)(nil), "fk_data.JobSchedule")
	proto.RegisterType((*Schedule)(nil), "fk_data.Schedule")
	proto.RegisterType((*Identity)(nil), "fk_data.Identity")
	proto.RegisterType((*Condition)(nil), "fk_data.Condition")
	proto.RegisterType((*NetworkInfo)(nil), "fk_data.NetworkInfo")
	proto.RegisterType((*WifiTransmission)(nil), "fk_data.WifiTransmission")
	proto.RegisterType((*TransmissionSettings)(nil), "fk_data.TransmissionSettings")
	proto.RegisterType((*NetworkSettings)(nil), "fk_data.NetworkSettings")
	proto.RegisterType((*LoraSettings)(nil), "fk_data.LoraSettings")
	proto.RegisterType((*DataRecord)(nil), "fk_data.DataRecord")
	proto.RegisterType((*SignedRecord)(nil), "fk_data.SignedRecord")
	proto.RegisterType((*LoraRecord)(nil), "fk_data.LoraRecord")
}

func init() { proto.RegisterFile("fk-data.proto", fileDescriptor_412c2faa5b3d2004) }

var fileDescriptor_412c2faa5b3d2004 = []byte{
	// 1846 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x58, 0x4f, 0x6f, 0x23, 0x49,
	0x15, 0xdf, 0xb6, 0x3b, 0xb1, 0xfd, 0x6c, 0x67, 0xbc, 0xb5, 0x61, 0xd6, 0xbb, 0x9b, 0xf1, 0x46,
	0xad, 0x85, 0x0d, 0x23, 0x12, 0x86, 0xec, 0x85, 0x03, 0x02, 0x79, 0x13, 0xcf, 0x8c, 0x99, 0xc4,
	0x91, 0xca, 0x59, 0x56, 0xe2, 0x12, 0xca, 0xee, 0xb2, 0xa7, 0x48, 0xbb, 0xdb, 0x54, 0x57, 0x27,
	0x84, 0x33, 0x1f, 0x00, 0x2e, 0x88, 0x2b, 0x9f, 0x00, 0x3e, 0x01, 0x67, 0x0e, 0x48, 0xf0, 0x11,
	0xd0, 0x70, 0xe2, 0x3b, 0x20, 0x81, 0xea, 0x6f, 0x57, 0x7b, 0x2d, 0xed, 0xce, 0xad, 0xde, 0xab,
	0x5f, 0x55, 0xbd, 0xff, 0xef, 0x75, 0x43, 0x77, 0x71, 0x7b, 0x1c, 0x13, 0x41, 0x4e, 0xd6, 0x3c,
	0x13, 0x19, 0x6a, 0x2c, 0x6e, 0x6f, 0x24, 0x19, 0xfd, 0x37, 0x80, 0xbd, 0x73, 0x7a, 0xc7, 0xe6,
	0xf4, 0x22, 0x9b, 0x13, 0xc1, 0xb2, 0x14, 0xf5, 0xa1, 0x41, 0x53, 0x32, 0x4b, 0x68, 0xdc, 0x6f,
	0x1c, 0x06, 0x47, 0x5d, 0x6c, 0x49, 0xd4, 0x83, 0xfa, 0x82, 0xfd, 0xba, 0x1f, 0x28, 0xae, 0x5c,
	0x22, 0x04, 0xa1, 0x60, 0x2b, 0xda, 0xaf, 0x1d, 0x06, 0x47, 0x75, 0xac, 0xd6, 0xe8, 0x00, 0x5a,
	0x49, 0x96, 0x2e, 0x99, 0x28, 0x62, 0xda, 0xaf, 0x1f, 0x06, 0x47, 0x35, 0x5c, 0x32, 0xd0, 0x87,
	0xd0, 0x4c, 0x88, 0xd0, 0x9b, 0xa1, 0xda, 0x74, 0xb4, 0xdc, 0x23, 0x89, 0xd9, 0xdb, 0xd1, 0x7b,
	0x96, 0x46, 0x87, 0xd0, 0x9e, 0x67, 0x19, 0x8f, 0x59, 0x4a, 0x04, 0xcd, 0xfb, 0xbb, 0x87, 0xf5,
	0xa3, 0x1a, 0xf6, 0x59, 0x68, 0x00, 0x90, 0x13, 0x41, 0x93, 0x84, 0x49, 0x40, 0x53, 0x09, 0xe9,
	0x71, 0xa4, 0xac, 0xaf, 0xe3, 0x6c, 0xdd, 0x6f, 0xa9, 0x1d, 0xb5, 0x8e, 0x6e, 0xa1, 0x3b, 0xa5,
	0x69, 0x9e, 0x71, 0x4c, 0x49, 0xcc, 0xd2, 0xa5, 0x54, 0x9e, 0xeb, 0xa5, 0x52, 0x33, 0xc4, 0x96,
	0xdc, 0xaa, 0xea, 0x63, 0xd8, 0xcd, 0xd5, 0x71, 0xa5, 0x67, 0x17, 0x1b, 0x0a, 0xed, 0xc3, 0xce,
	0x1d, 0x49, 0x0a, 0xab, 0xa1, 0x26, 0xa2, 0xdf, 0x05, 0xd0, 0xbd, 0xc8, 0x96, 0x4b, 0x1a, 0x7b,
	0xaf, 0xdd, 0x51, 0x9e, 0xb3, 0x2c, 0x35, 0x46, 0xb5, 0x24, 0xfa, 0x0c, 0x9a, 0x89, 0x71, 0x88,
	0x7a, 0xb1, 0x7d, 0xfa, 0xfe, 0x89, 0xf1, 0xd9, 0x49, 0xd5, 0x5f, 0xd8, 0x01, 0xd1, 0xb3, 0x52,
	0xf8, 0xba, 0x3a, 0xf3, 0xd8, 0x9d, 0xa9, 0x68, 0xe9, 0x94, 0x8a, 0x7e, 0x0c, 0x7b, 0x7a, 0x67,
	0x98, 0xc6, 0x3f, 0x93, 0x42, 0x7a, 0x2a, 0x05, 0xdb, 0x55, 0xaa, 0xf9, 0x2a, 0xfd, 0x02, 0x3a,
	0x97, 0x59, 0x5c, 0x24, 0xf4, 0x25, 0x25, 0x31, 0xe5, 0x28, 0x82, 0xce, 0x8a, 0xa4, 0xc5, 0x82,
	0xcc, 0x45, 0xc1, 0xa9, 0xbd, 0xa3, 0xc2, 0x93, 0x86, 0xbc, 0x65, 0x69, 0xac, 0x2e, 0xea, 0x62,
	0xb5, 0xf6, 0x0d, 0x51, 0xaf, 0x18, 0x22, 0xfa, 0x53, 0x0d, 0x40, 0x3f, 0x31, 0x4e, 0x17, 0x99,
	0x0c, 0x91, 0x75, 0x96, 0x33, 0x51, 0x9a, 0xcc, 0xd1, 0xf2, 0x12, 0x12, 0xc7, 0x9c, 0xe6, 0xb9,
	0xb9, 0xdb, 0x92, 0xf2, 0xc9, 0x94, 0xac, 0x74, 0x34, 0xb6, 0xb0, 0x5a, 0xa3, 0x63, 0xd8, 0x7d,
	0xad, 0x84, 0x56, 0x4e, 0x6a, 0x9f, 0x7e, 0xcb, 0xd9, 0xca, 0xd7, 0x08, 0x1b, 0x10, 0x3a, 0x86,
	0xe6, 0x82, 0xf1, 0xd5, 0x3d, 0xe1, 0x3a, 0x36, 0xdb, 0xa7, 0xef, 0xba, 0x03, 0xcf, 0xcd, 0x06,
	0x76, 0x10, 0x74, 0x0c, 0x0d, 0x6d, 0x38, 0x1d, 0xaa, 0xed, 0xd3, 0xf7, 0x36, 0x5c, 0x21, 0xb5,
	0xc1, 0x16, 0x83, 0xf6, 0xa0, 0xc6, 0x74, 0xba, 0x75, 0x70, 0x8d, 0xc5, 0xd2, 0xda, 0x8b, 0x84,
	0x2c, 0x6d, 0x18, 0x6b, 0x42, 0xf9, 0x46, 0x10, 0x51, 0xe4, 0x2a, 0x86, 0x3b, 0xd8, 0x50, 0x91,
	0x00, 0x28, 0x2f, 0x95, 0xa8, 0xb4, 0x58, 0xcd, 0x9c, 0xf5, 0x0d, 0xe5, 0x8c, 0x50, 0xf3, 0x8c,
	0xf0, 0x09, 0x74, 0x8b, 0x94, 0x89, 0xab, 0xc5, 0x25, 0x25, 0x79, 0xc1, 0xad, 0x85, 0xaa, 0xcc,
	0x52, 0x9a, 0xd0, 0x93, 0x26, 0xfa, 0x6d, 0x00, 0x4d, 0xab, 0xf9, 0x66, 0x24, 0xb7, 0xca, 0x48,
	0xde, 0x87, 0x9d, 0x59, 0xc1, 0x92, 0xd8, 0xbc, 0xab, 0x09, 0x4f, 0x48, 0xfd, 0xa2, 0x15, 0xf2,
	0x00, 0x5a, 0x32, 0xb3, 0x72, 0x41, 0x56, 0x6b, 0xf5, 0x5c, 0x88, 0x4b, 0x86, 0x4a, 0x61, 0x92,
	0xbf, 0x56, 0x0e, 0x68, 0x61, 0xb5, 0x8e, 0xfe, 0x5c, 0x83, 0xe6, 0x25, 0x15, 0x44, 0xda, 0x56,
	0x86, 0x47, 0xac, 0xb2, 0x63, 0x1c, 0x2b, 0x39, 0x3a, 0xd8, 0xd1, 0x5b, 0x13, 0xb8, 0x07, 0xf5,
	0x25, 0x13, 0x46, 0x06, 0xb9, 0x2c, 0xc5, 0x6d, 0xf8, 0xe2, 0x0e, 0x00, 0x38, 0xcd, 0xa9, 0x38,
	0x23, 0x45, 0x4e, 0x8d, 0x19, 0x3c, 0x8e, 0xef, 0xee, 0x9d, 0x6f, 0xe0, 0xee, 0x63, 0x68, 0xac,
	0x54, 0x90, 0x7d, 0x35, 0x3a, 0xca, 0x58, 0xc7, 0x16, 0x53, 0x89, 0xbd, 0xe6, 0xd7, 0xc7, 0xde,
	0x00, 0x60, 0x49, 0x53, 0xca, 0x75, 0xf5, 0xd0, 0xa1, 0xe2, 0x71, 0xa2, 0xdf, 0xc0, 0xee, 0x54,
	0x05, 0x8e, 0x33, 0x49, 0x50, 0xad, 0x69, 0xc5, 0xda, 0x19, 0xaa, 0x8b, 0x0d, 0x25, 0x3d, 0x3c,
	0x23, 0x42, 0x50, 0xfe, 0x60, 0x8a, 0xba, 0x25, 0xe5, 0x89, 0x15, 0x5d, 0x65, 0xfc, 0xc1, 0x18,
	0xc6, 0x50, 0xf2, 0xf6, 0x59, 0x91, 0x3f, 0x28, 0x6f, 0x85, 0x58, 0xad, 0x65, 0xd0, 0xc0, 0x45,
	0xb6, 0xbc, 0xa4, 0x79, 0x4e, 0x96, 0xf4, 0xad, 0x04, 0xd8, 0x87, 0x9d, 0x84, 0xde, 0xd1, 0xc4,
	0x54, 0x08, 0x4d, 0x48, 0x8f, 0x2f, 0xc8, 0x9c, 0x25, 0x4c, 0xe8, 0xe7, 0x5b, 0xd8, 0xd1, 0x52,
	0xe4, 0x95, 0x7e, 0xc8, 0x44, 0x8c, 0x25, 0xa3, 0x9f, 0x43, 0x5b, 0xfb, 0xe5, 0x05, 0xcf, 0x8a,
	0xb5, 0xd2, 0x40, 0xd9, 0xda, 0xa6, 0x8c, 0xa6, 0x64, 0x15, 0x36, 0x95, 0x52, 0x96, 0x94, 0x7a,
	0xa5, 0x0a, 0x57, 0xeb, 0x26, 0x76, 0xc0, 0xe8, 0x3f, 0x01, 0x34, 0x4d, 0xa1, 0xdd, 0x6e, 0x61,
	0xaf, 0xc7, 0xd4, 0xaa, 0x3d, 0xc6, 0x25, 0x5a, 0xdd, 0x4f, 0x7b, 0x04, 0xe1, 0x8a, 0x0a, 0xd2,
	0xdf, 0xd5, 0x76, 0x94, 0x6b, 0xcf, 0x48, 0x8d, 0x8a, 0x91, 0xfc, 0xbe, 0x11, 0x7e, 0xd3, 0xbe,
	0xf1, 0x43, 0xe8, 0xe4, 0xa5, 0x35, 0x6c, 0x08, 0xef, 0x6f, 0xa8, 0xaa, 0x36, 0x71, 0x05, 0x19,
	0x4d, 0xa0, 0x39, 0x4e, 0x05, 0xe5, 0x77, 0x24, 0x91, 0xc2, 0xe7, 0x82, 0x70, 0x61, 0x1a, 0xa7,
	0x26, 0x64, 0x86, 0x51, 0x53, 0xec, 0x43, 0x2c, 0x97, 0xd2, 0x63, 0xcc, 0x9c, 0x31, 0x7a, 0x3a,
	0x3a, 0xfa, 0x6b, 0x00, 0xed, 0x9f, 0x66, 0xb3, 0xe9, 0xfc, 0x35, 0x55, 0x0e, 0x40, 0x10, 0xce,
	0xb9, 0xa9, 0x29, 0x1d, 0xac, 0xd6, 0x95, 0xf3, 0xb5, 0xea, 0x79, 0xb9, 0xc7, 0xe9, 0x9a, 0x12,
	0x41, 0x63, 0x7b, 0xb7, 0xa5, 0x55, 0x6d, 0x28, 0x78, 0x69, 0x9a, 0x2e, 0x76, 0xb4, 0x34, 0xe7,
	0x2f, 0x99, 0x8c, 0x66, 0x15, 0x28, 0x5d, 0x6c, 0x28, 0xf4, 0x7d, 0x68, 0xd9, 0xbb, 0x6d, 0xaa,
	0x96, 0xa9, 0x67, 0x35, 0xc7, 0x25, 0x46, 0x2a, 0xd0, 0x74, 0xd2, 0x3f, 0xf3, 0xc2, 0x27, 0x50,
	0xce, 0x28, 0x6d, 0xea, 0x69, 0x59, 0xc6, 0x0e, 0x3a, 0x81, 0x46, 0x4a, 0xc5, 0x7d, 0xc6, 0x6f,
	0x4d, 0xd7, 0xdf, 0x7e, 0xc0, 0x82, 0xd0, 0x11, 0x84, 0x49, 0xc6, 0x89, 0x69, 0xf7, 0xdb, 0xc1,
	0x0a, 0x81, 0xbe, 0x03, 0xf5, 0xe5, 0x3a, 0x37, 0x31, 0xb1, 0x1d, 0x28, 0x01, 0xd1, 0x00, 0x9a,
	0xe3, 0x98, 0xa6, 0x42, 0xe6, 0x8f, 0xed, 0x18, 0x41, 0xd9, 0x31, 0xa2, 0x9f, 0x40, 0xeb, 0x2c,
	0x4b, 0x63, 0xdd, 0x71, 0x5d, 0xbc, 0x06, 0x7e, 0xbc, 0x1e, 0x40, 0x8b, 0xd3, 0xb9, 0x1a, 0xcc,
	0x96, 0xc6, 0x43, 0x25, 0x23, 0xca, 0xa1, 0x3d, 0xd1, 0xd2, 0xab, 0x6e, 0x85, 0x20, 0xcc, 0x73,
	0x16, 0xdb, 0x37, 0xe4, 0x5a, 0x35, 0x79, 0x92, 0xe7, 0xf7, 0x19, 0xb7, 0x5d, 0xc3, 0xd1, 0xd2,
	0x53, 0x73, 0x2e, 0x1d, 0xaa, 0x74, 0x6e, 0x62, 0x43, 0xc9, 0x47, 0xd7, 0x9c, 0x2e, 0x28, 0xe7,
	0x34, 0x56, 0x5a, 0x36, 0x71, 0xc9, 0x88, 0xae, 0xa1, 0xf7, 0x25, 0x5b, 0xb0, 0x6b, 0x4e, 0xd2,
	0x7c, 0xc5, 0x72, 0xd5, 0x98, 0x7a, 0x50, 0x2f, 0x78, 0x62, 0x1e, 0x96, 0x4b, 0xa9, 0x8e, 0xc8,
	0x6e, 0x69, 0x6a, 0x5b, 0x95, 0x22, 0xfc, 0x79, 0x58, 0x3f, 0x69, 0xc9, 0x68, 0x04, 0xfb, 0xfe,
	0x8d, 0x53, 0x2a, 0x84, 0xf2, 0xe2, 0x31, 0x84, 0xf7, 0x6c, 0xc1, 0x8c, 0xcf, 0x3f, 0x70, 0xc6,
	0xde, 0x14, 0x01, 0x2b, 0x58, 0x74, 0x06, 0x8f, 0x8c, 0x45, 0xdc, 0x0d, 0xcf, 0xa0, 0x69, 0x5c,
	0x2c, 0x6d, 0x5b, 0xcd, 0x46, 0xcf, 0x7a, 0xd8, 0xa1, 0xa2, 0xbf, 0xd7, 0xa0, 0x73, 0x91, 0x71,
	0xe2, 0xae, 0x38, 0x80, 0x96, 0x6e, 0x7d, 0xa3, 0x82, 0x99, 0xfc, 0x29, 0x19, 0xd2, 0x8c, 0x64,
	0xbd, 0x7e, 0x45, 0x1f, 0x94, 0xae, 0x1d, 0x6c, 0x28, 0xc3, 0x97, 0x47, 0xea, 0x8e, 0x2f, 0xf1,
	0x9f, 0x40, 0x77, 0xc1, 0xe9, 0xaf, 0x0a, 0x9a, 0xce, 0x1f, 0x3e, 0x27, 0x69, 0x6c, 0x32, 0xa8,
	0xca, 0x94, 0x28, 0xfd, 0xc4, 0xd0, 0xcc, 0x61, 0x3b, 0xea, 0x92, 0x2a, 0x13, 0x7d, 0x0f, 0xde,
	0x4d, 0xad, 0xbe, 0xca, 0x0e, 0x52, 0x8c, 0x5d, 0x85, 0xfc, 0xea, 0x86, 0xbc, 0x93, 0xac, 0xd7,
	0x1e, 0x52, 0x4f, 0x49, 0x55, 0xa6, 0x1a, 0x64, 0xd6, 0x09, 0x4b, 0x6f, 0xcf, 0xb2, 0x42, 0x26,
	0xa3, 0x19, 0x9c, 0xaa, 0x4c, 0x74, 0x04, 0x8f, 0xe2, 0xec, 0x3e, 0xf5, 0x71, 0xfa, 0x6b, 0x60,
	0x93, 0x1d, 0xfd, 0x61, 0x07, 0xe0, 0x9c, 0x08, 0x82, 0x55, 0xdc, 0xa2, 0x1f, 0x41, 0x37, 0xf1,
	0x27, 0x77, 0xe3, 0xda, 0x72, 0xbe, 0xae, 0xcc, 0xf5, 0xb8, 0x0a, 0x96, 0xfd, 0x7b, 0x65, 0x26,
	0x14, 0x93, 0xd6, 0x65, 0x11, 0xb1, 0xa3, 0x0b, 0x76, 0x10, 0xf4, 0x6d, 0xa8, 0x27, 0x99, 0x1d,
	0xe1, 0xdf, 0xf3, 0x9f, 0x30, 0x6d, 0x13, 0xcb, 0x7d, 0xf4, 0xa9, 0xcc, 0xfd, 0x65, 0xde, 0xef,
	0x6e, 0x4c, 0x10, 0x1e, 0x4e, 0x01, 0xd0, 0xa7, 0x6e, 0x6c, 0xd4, 0xd9, 0xff, 0xa8, 0x2c, 0xec,
	0x8a, 0x6d, 0xe7, 0x48, 0x29, 0xa7, 0xab, 0x57, 0x9b, 0x33, 0xae, 0xed, 0x68, 0x5e, 0xb1, 0x7a,
	0xfb, 0x29, 0x26, 0x37, 0xa5, 0x46, 0xf9, 0xd0, 0xbf, 0xbd, 0x2c, 0x85, 0xb9, 0x57, 0xfa, 0x55,
	0xd7, 0x6b, 0x7a, 0x5d, 0xef, 0x18, 0x9a, 0xcc, 0x14, 0x27, 0xe5, 0xb8, 0x4a, 0x35, 0x36, 0x1b,
	0xd8, 0x41, 0xd0, 0x33, 0x68, 0xcd, 0x6d, 0xad, 0xea, 0x83, 0xc2, 0x23, 0x87, 0x77, 0x55, 0x0c,
	0x97, 0x20, 0xf4, 0x5d, 0x53, 0x4f, 0xdb, 0x1b, 0x9f, 0x04, 0x7e, 0x66, 0x99, 0x82, 0x7a, 0x5a,
	0x96, 0xea, 0x8e, 0x42, 0xf7, 0x37, 0x33, 0xd4, 0x1d, 0x70, 0xe5, 0x7a, 0x08, 0x1d, 0xe1, 0xe5,
	0x7f, 0x7f, 0x4f, 0x1d, 0x7c, 0xe2, 0x0e, 0x6e, 0xab, 0x26, 0xb8, 0x72, 0x24, 0xfa, 0x7d, 0x00,
	0x9d, 0x29, 0x5b, 0xa6, 0x32, 0xba, 0x54, 0x68, 0x1e, 0x9b, 0xcf, 0x29, 0x19, 0x91, 0x7b, 0x5e,
	0xb1, 0xf1, 0x41, 0xaf, 0x58, 0x1a, 0x9b, 0x2f, 0xad, 0x6d, 0x53, 0x30, 0x82, 0x50, 0xc5, 0xa6,
	0x4e, 0x79, 0xb5, 0x76, 0xa3, 0x76, 0xa8, 0x79, 0x72, 0x2d, 0x8b, 0x83, 0xae, 0xe3, 0x66, 0xa4,
	0x33, 0x54, 0xf4, 0x17, 0x35, 0xd4, 0x71, 0x9b, 0x2c, 0x6f, 0x3b, 0x84, 0x57, 0xbf, 0x05, 0x42,
	0xf7, 0x2d, 0x50, 0x4e, 0x65, 0x61, 0x65, 0x2a, 0x2b, 0x3f, 0x51, 0x8d, 0x18, 0xe6, 0x13, 0xf5,
	0x31, 0xec, 0xaa, 0xaf, 0x52, 0xfb, 0x77, 0xc0, 0x50, 0x4e, 0xbd, 0x46, 0xa9, 0xde, 0xd3, 0x19,
	0x74, 0xcf, 0x65, 0xca, 0x67, 0x24, 0x7e, 0x6e, 0xbe, 0xad, 0x10, 0x1e, 0x0d, 0xcf, 0xc7, 0x93,
	0x17, 0x37, 0xcf, 0x2f, 0x86, 0x2f, 0xa6, 0x37, 0x93, 0xab, 0xc9, 0xa8, 0xf7, 0x0e, 0xfa, 0x18,
	0x3e, 0xda, 0xe4, 0x5f, 0xdf, 0xe0, 0xd1, 0xd9, 0x15, 0x96, 0xbc, 0x5e, 0x80, 0xfa, 0xb0, 0x5f,
	0x05, 0x5c, 0x0e, 0x27, 0x5f, 0x0c, 0x2f, 0x7a, 0xb5, 0xa7, 0x63, 0xd8, 0x73, 0x41, 0xa6, 0x1f,
	0xe9, 0xc3, 0xfe, 0xd9, 0xd5, 0xe4, 0x7c, 0x7c, 0x3d, 0xbe, 0x9a, 0x54, 0x9f, 0x79, 0x02, 0x1f,
	0x6c, 0xee, 0x78, 0x8f, 0x3c, 0xfd, 0x47, 0x00, 0xbd, 0x4d, 0x87, 0xa2, 0x8f, 0xe0, 0xfd, 0xe9,
	0xf8, 0xc5, 0x64, 0x74, 0x6e, 0xa0, 0x37, 0xaf, 0xc6, 0x93, 0x73, 0x7b, 0xe1, 0x00, 0x3e, 0xdc,
	0xb2, 0x79, 0x79, 0x75, 0xfe, 0xc5, 0xc5, 0x68, 0xda, 0x0b, 0xa4, 0x5e, 0x5b, 0xf6, 0xa7, 0x67,
	0x2f, 0x47, 0x12, 0xd1, 0xab, 0xa1, 0x03, 0xe8, 0x6f, 0x03, 0x5c, 0x0f, 0xaf, 0x47, 0xbd, 0x3a,
	0x3a, 0x84, 0x83, 0x2d, 0xbb, 0x78, 0xf8, 0xa5, 0x41, 0x84, 0xe8, 0xc9, 0xd6, 0xf3, 0x57, 0xd7,
	0x2f, 0x47, 0xb8, 0xf7, 0xbf, 0xe0, 0xf3, 0x1f, 0xfc, 0xed, 0xcd, 0x20, 0xf8, 0xe7, 0x9b, 0x41,
	0xf0, 0xaf, 0x37, 0x83, 0xe0, 0x8f, 0xff, 0x1e, 0xbc, 0x03, 0x1f, 0x67, 0x7c, 0x79, 0x32, 0xcf,
	0xd2, 0x9c, 0xf2, 0x3b, 0xb6, 0x78, 0x38, 0x59, 0x30, 0x9a, 0xc4, 0xb7, 0x4c, 0x9c, 0xe8, 0xff,
	0x56, 0xb3, 0xd9, 0xae, 0xfa, 0x77, 0xf5, 0xd9, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0x28, 0xc5,
	0x8d, 0x4d, 0xcc, 0x12, 0x00, 0x00,
}

func (m *DeviceLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Hdop != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Hdop))
		i--
		dAtA[i] = 0x48
	}
	if m.Satellites != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Satellites))
		i--
		dAtA[i] = 0x40
	}
	if m.Enabled != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Enabled))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Coordinates) > 0 {
		for iNdEx := len(m.Coordinates) - 1; iNdEx >= 0; iNdEx-- {
			f1 := math.Float32bits(float32(m.Coordinates[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f1))
		}
		i = encodeVarintFkData(dAtA, i, uint64(len(m.Coordinates)*4))
		i--
		dAtA[i] = 0x32
	}
	if m.Altitude != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Altitude))))
		i--
		dAtA[i] = 0x2d
	}
	if m.Latitude != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Latitude))))
		i--
		dAtA[i] = 0x25
	}
	if m.Longitude != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Longitude))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Time != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x10
	}
	if m.Fix != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Fix))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SensorReading) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SensorReading) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SensorReading) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Value))))
		i--
		dAtA[i] = 0x25
	}
	if m.Sensor != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Sensor))
		i--
		dAtA[i] = 0x18
	}
	if m.Time != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x10
	}
	if m.Reading != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Reading))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LoggedReading) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoggedReading) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoggedReading) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Reading != nil {
		{
			size, err := m.Reading.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFkData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFkData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Version != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SensorAndValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SensorAndValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SensorAndValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Value))))
		i--
		dAtA[i] = 0x15
	}
	if m.Sensor != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Sensor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ModuleHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModuleHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Version != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if m.Kind != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x10
	}
	if m.Manufacturer != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Manufacturer))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ModuleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModuleInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Flags != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Sensors) > 0 {
		for iNdEx := len(m.Sensors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sensors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFkData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Firmware != nil {
		{
			size, err := m.Firmware.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFkData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFkData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Address != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Address))
		i--
		dAtA[i] = 0x10
	}
	if m.Position != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Position))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SensorInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SensorInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SensorInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Flags != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x20
	}
	if len(m.UnitOfMeasure) > 0 {
		i -= len(m.UnitOfMeasure)
		copy(dAtA[i:], m.UnitOfMeasure)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.UnitOfMeasure)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Number != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Firmware) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Firmware) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Firmware) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Timestamp != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Number) > 0 {
		i -= len(m.Number)
		copy(dAtA[i:], m.Number)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.Number)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Build) > 0 {
		i -= len(m.Build)
		copy(dAtA[i:], m.Build)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.Build)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Generation) > 0 {
		i -= len(m.Generation)
		copy(dAtA[i:], m.Generation)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.Generation)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Firmware != nil {
		{
			size, err := m.Firmware.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFkData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.Build) > 0 {
		i -= len(m.Build)
		copy(dAtA[i:], m.Build)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.Build)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Modules) > 0 {
		for iNdEx := len(m.Modules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Modules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFkData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Sensors) > 0 {
		for iNdEx := len(m.Sensors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sensors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFkData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ResetCause != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.ResetCause))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Git) > 0 {
		i -= len(m.Git)
		copy(dAtA[i:], m.Git)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.Git)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Time != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x10
	}
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Busy != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Busy))
		i--
		dAtA[i] = 0x28
	}
	if m.Memory != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Memory))
		i--
		dAtA[i] = 0x20
	}
	if m.Battery != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Battery))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Uptime != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Uptime))
		i--
		dAtA[i] = 0x10
	}
	if m.Time != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LogMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Facility) > 0 {
		i -= len(m.Facility)
		copy(dAtA[i:], m.Facility)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.Facility)))
		i--
		dAtA[i] = 0x22
	}
	if m.Level != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x18
	}
	if m.Uptime != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Uptime))
		i--
		dAtA[i] = 0x10
	}
	if m.Time != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SensorGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SensorGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SensorGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Readings) > 0 {
		for iNdEx := len(m.Readings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Readings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFkData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Module != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Module))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Readings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Readings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Readings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Uptime != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Uptime))
		i--
		dAtA[i] = 0x38
	}
	if m.Meta != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Meta))
		i--
		dAtA[i] = 0x30
	}
	if len(m.SensorGroups) > 0 {
		for iNdEx := len(m.SensorGroups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SensorGroups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFkData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFkData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Flags != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x18
	}
	if m.Reading != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Reading))
		i--
		dAtA[i] = 0x10
	}
	if m.Time != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Interval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Interval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Interval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Interval != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Interval))
		i--
		dAtA[i] = 0x18
	}
	if m.End != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *JobSchedule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobSchedule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobSchedule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Intervals) > 0 {
		for iNdEx := len(m.Intervals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Intervals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFkData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Jitter != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Jitter))
		i--
		dAtA[i] = 0x28
	}
	if m.Duration != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x20
	}
	if m.Repeated != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Repeated))
		i--
		dAtA[i] = 0x18
	}
	if m.Interval != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Interval))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Cron) > 0 {
		i -= len(m.Cron)
		copy(dAtA[i:], m.Cron)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.Cron)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Schedule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Schedule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Schedule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Gps != nil {
		{
			size, err := m.Gps.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFkData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Lora != nil {
		{
			size, err := m.Lora.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFkData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Network != nil {
		{
			size, err := m.Network.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFkData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Readings != nil {
		{
			size, err := m.Readings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFkData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Identity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Identity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Identity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Condition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Condition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Condition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Recording != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Recording))
		i--
		dAtA[i] = 0x10
	}
	if m.Flags != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NetworkInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Preferred {
		i--
		if m.Preferred {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Create {
		i--
		if m.Create {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Ssid) > 0 {
		i -= len(m.Ssid)
		copy(dAtA[i:], m.Ssid)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.Ssid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WifiTransmission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WifiTransmission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WifiTransmission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransmissionSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransmissionSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransmissionSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Wifi != nil {
		{
			size, err := m.Wifi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFkData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Networks) > 0 {
		for iNdEx := len(m.Networks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Networks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFkData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LoraSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoraSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoraSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DownlinkCounter != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.DownlinkCounter))
		i--
		dAtA[i] = 0x48
	}
	if m.UplinkCounter != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.UplinkCounter))
		i--
		dAtA[i] = 0x40
	}
	if len(m.AppSessionKey) > 0 {
		i -= len(m.AppSessionKey)
		copy(dAtA[i:], m.AppSessionKey)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.AppSessionKey)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.NetworkSessionKey) > 0 {
		i -= len(m.NetworkSessionKey)
		copy(dAtA[i:], m.NetworkSessionKey)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.NetworkSessionKey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DeviceAddress) > 0 {
		i -= len(m.DeviceAddress)
		copy(dAtA[i:], m.DeviceAddress)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.DeviceAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if m.FrequencyBand != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.FrequencyBand))
		i--
		dAtA[i] = 0x20
	}
	if len(m.AppEui) > 0 {
		i -= len(m.AppEui)
		copy(dAtA[i:], m.AppEui)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.AppEui)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AppKey) > 0 {
		i -= len(m.AppKey)
		copy(dAtA[i:], m.AppKey)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.AppKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DeviceEui) > 0 {
		i -= len(m.DeviceEui)
		copy(dAtA[i:], m.DeviceEui)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.DeviceEui)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Transmission != nil {
		{
			size, err := m.Transmission.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFkData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if len(m.Logs) > 0 {
		for iNdEx := len(m.Logs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Logs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFkData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.Network != nil {
		{
			size, err := m.Network.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFkData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.Lora != nil {
		{
			size, err := m.Lora.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFkData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Condition != nil {
		{
			size, err := m.Condition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFkData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Identity != nil {
		{
			size, err := m.Identity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFkData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Meta != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Meta))
		i--
		dAtA[i] = 0x40
	}
	if m.Schedule != nil {
		{
			size, err := m.Schedule.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFkData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Modules) > 0 {
		for iNdEx := len(m.Modules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Modules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFkData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Readings != nil {
		{
			size, err := m.Readings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFkData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFkData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Log != nil {
		{
			size, err := m.Log.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFkData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFkData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LoggedReading != nil {
		{
			size, err := m.LoggedReading.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFkData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignedRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignedRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignedRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Record != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Record))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Time != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x10
	}
	if m.Kind != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LoraRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoraRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoraRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			f24 := math.Float32bits(float32(m.Values[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f24))
		}
		i = encodeVarintFkData(dAtA, i, uint64(len(m.Values)*4))
		i--
		dAtA[i] = 0x32
	}
	if m.Sensor != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Sensor))
		i--
		dAtA[i] = 0x28
	}
	if m.Module != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Module))
		i--
		dAtA[i] = 0x20
	}
	if m.Number != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x18
	}
	if m.Time != 0 {
		i = encodeVarintFkData(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x10
	}
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintFkData(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintFkData(dAtA []byte, offset int, v uint64) int {
	offset -= sovFkData(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DeviceLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fix != 0 {
		n += 1 + sovFkData(uint64(m.Fix))
	}
	if m.Time != 0 {
		n += 1 + sovFkData(uint64(m.Time))
	}
	if m.Longitude != 0 {
		n += 5
	}
	if m.Latitude != 0 {
		n += 5
	}
	if m.Altitude != 0 {
		n += 5
	}
	if len(m.Coordinates) > 0 {
		n += 1 + sovFkData(uint64(len(m.Coordinates)*4)) + len(m.Coordinates)*4
	}
	if m.Enabled != 0 {
		n += 1 + sovFkData(uint64(m.Enabled))
	}
	if m.Satellites != 0 {
		n += 1 + sovFkData(uint64(m.Satellites))
	}
	if m.Hdop != 0 {
		n += 1 + sovFkData(uint64(m.Hdop))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SensorReading) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reading != 0 {
		n += 1 + sovFkData(uint64(m.Reading))
	}
	if m.Time != 0 {
		n += 1 + sovFkData(uint64(m.Time))
	}
	if m.Sensor != 0 {
		n += 1 + sovFkData(uint64(m.Sensor))
	}
	if m.Value != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoggedReading) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovFkData(uint64(m.Version))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.Reading != nil {
		l = m.Reading.Size()
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SensorAndValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sensor != 0 {
		n += 1 + sovFkData(uint64(m.Sensor))
	}
	if m.Value != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ModuleHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Manufacturer != 0 {
		n += 1 + sovFkData(uint64(m.Manufacturer))
	}
	if m.Kind != 0 {
		n += 1 + sovFkData(uint64(m.Kind))
	}
	if m.Version != 0 {
		n += 1 + sovFkData(uint64(m.Version))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ModuleInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Position != 0 {
		n += 1 + sovFkData(uint64(m.Position))
	}
	if m.Address != 0 {
		n += 1 + sovFkData(uint64(m.Address))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.Firmware != nil {
		l = m.Firmware.Size()
		n += 1 + l + sovFkData(uint64(l))
	}
	if len(m.Sensors) > 0 {
		for _, e := range m.Sensors {
			l = e.Size()
			n += 1 + l + sovFkData(uint64(l))
		}
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.Flags != 0 {
		n += 1 + sovFkData(uint64(m.Flags))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SensorInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovFkData(uint64(m.Number))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	l = len(m.UnitOfMeasure)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.Flags != 0 {
		n += 1 + sovFkData(uint64(m.Flags))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Firmware) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	l = len(m.Build)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	l = len(m.Number)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovFkData(uint64(m.Timestamp))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovFkData(uint64(m.Time))
	}
	l = len(m.Git)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.ResetCause != 0 {
		n += 1 + sovFkData(uint64(m.ResetCause))
	}
	if len(m.Sensors) > 0 {
		for _, e := range m.Sensors {
			l = e.Size()
			n += 1 + l + sovFkData(uint64(l))
		}
	}
	if len(m.Modules) > 0 {
		for _, e := range m.Modules {
			l = e.Size()
			n += 1 + l + sovFkData(uint64(l))
		}
	}
	l = len(m.Build)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.Firmware != nil {
		l = m.Firmware.Size()
		n += 1 + l + sovFkData(uint64(l))
	}
	l = len(m.Generation)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Status) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovFkData(uint64(m.Time))
	}
	if m.Uptime != 0 {
		n += 1 + sovFkData(uint64(m.Uptime))
	}
	if m.Battery != 0 {
		n += 5
	}
	if m.Memory != 0 {
		n += 1 + sovFkData(uint64(m.Memory))
	}
	if m.Busy != 0 {
		n += 1 + sovFkData(uint64(m.Busy))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LogMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovFkData(uint64(m.Time))
	}
	if m.Uptime != 0 {
		n += 1 + sovFkData(uint64(m.Uptime))
	}
	if m.Level != 0 {
		n += 1 + sovFkData(uint64(m.Level))
	}
	l = len(m.Facility)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SensorGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Module != 0 {
		n += 1 + sovFkData(uint64(m.Module))
	}
	if len(m.Readings) > 0 {
		for _, e := range m.Readings {
			l = e.Size()
			n += 1 + l + sovFkData(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Readings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovFkData(uint64(m.Time))
	}
	if m.Reading != 0 {
		n += 1 + sovFkData(uint64(m.Reading))
	}
	if m.Flags != 0 {
		n += 1 + sovFkData(uint64(m.Flags))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovFkData(uint64(l))
	}
	if len(m.SensorGroups) > 0 {
		for _, e := range m.SensorGroups {
			l = e.Size()
			n += 1 + l + sovFkData(uint64(l))
		}
	}
	if m.Meta != 0 {
		n += 1 + sovFkData(uint64(m.Meta))
	}
	if m.Uptime != 0 {
		n += 1 + sovFkData(uint64(m.Uptime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Interval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovFkData(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovFkData(uint64(m.End))
	}
	if m.Interval != 0 {
		n += 1 + sovFkData(uint64(m.Interval))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JobSchedule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cron)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.Interval != 0 {
		n += 1 + sovFkData(uint64(m.Interval))
	}
	if m.Repeated != 0 {
		n += 1 + sovFkData(uint64(m.Repeated))
	}
	if m.Duration != 0 {
		n += 1 + sovFkData(uint64(m.Duration))
	}
	if m.Jitter != 0 {
		n += 1 + sovFkData(uint64(m.Jitter))
	}
	if len(m.Intervals) > 0 {
		for _, e := range m.Intervals {
			l = e.Size()
			n += 1 + l + sovFkData(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Schedule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Readings != nil {
		l = m.Readings.Size()
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.Network != nil {
		l = m.Network.Size()
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.Lora != nil {
		l = m.Lora.Size()
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.Gps != nil {
		l = m.Gps.Size()
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Identity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Condition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovFkData(uint64(m.Flags))
	}
	if m.Recording != 0 {
		n += 1 + sovFkData(uint64(m.Recording))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ssid)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.Create {
		n += 2
	}
	if m.Preferred {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WifiTransmission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransmissionSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Wifi != nil {
		l = m.Wifi.Size()
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Networks) > 0 {
		for _, e := range m.Networks {
			l = e.Size()
			n += 1 + l + sovFkData(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoraSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeviceEui)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	l = len(m.AppKey)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	l = len(m.AppEui)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.FrequencyBand != 0 {
		n += 1 + sovFkData(uint64(m.FrequencyBand))
	}
	l = len(m.DeviceAddress)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	l = len(m.NetworkSessionKey)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	l = len(m.AppSessionKey)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.UplinkCounter != 0 {
		n += 1 + sovFkData(uint64(m.UplinkCounter))
	}
	if m.DownlinkCounter != 0 {
		n += 1 + sovFkData(uint64(m.DownlinkCounter))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LoggedReading != nil {
		l = m.LoggedReading.Size()
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.Log != nil {
		l = m.Log.Size()
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.Readings != nil {
		l = m.Readings.Size()
		n += 1 + l + sovFkData(uint64(l))
	}
	if len(m.Modules) > 0 {
		for _, e := range m.Modules {
			l = e.Size()
			n += 1 + l + sovFkData(uint64(l))
		}
	}
	if m.Schedule != nil {
		l = m.Schedule.Size()
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.Meta != 0 {
		n += 1 + sovFkData(uint64(m.Meta))
	}
	if m.Identity != nil {
		l = m.Identity.Size()
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.Condition != nil {
		l = m.Condition.Size()
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.Lora != nil {
		l = m.Lora.Size()
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.Network != nil {
		l = m.Network.Size()
		n += 1 + l + sovFkData(uint64(l))
	}
	if len(m.Logs) > 0 {
		for _, e := range m.Logs {
			l = e.Size()
			n += 1 + l + sovFkData(uint64(l))
		}
	}
	if m.Transmission != nil {
		l = m.Transmission.Size()
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignedRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovFkData(uint64(m.Kind))
	}
	if m.Time != 0 {
		n += 1 + sovFkData(uint64(m.Time))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.Record != 0 {
		n += 1 + sovFkData(uint64(m.Record))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoraRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovFkData(uint64(m.Time))
	}
	if m.Number != 0 {
		n += 1 + sovFkData(uint64(m.Number))
	}
	if m.Module != 0 {
		n += 1 + sovFkData(uint64(m.Module))
	}
	if m.Sensor != 0 {
		n += 1 + sovFkData(uint64(m.Sensor))
	}
	if len(m.Values) > 0 {
		n += 1 + sovFkData(uint64(len(m.Values)*4)) + len(m.Values)*4
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovFkData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovFkData(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFkData(x uint64) (n int) {
	return sovFkData(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DeviceLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fix", wireType)
			}
			m.Fix = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fix |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Longitude = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Latitude = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Altitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Altitude = float32(math.Float32frombits(v))
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Coordinates = append(m.Coordinates, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFkData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFkData
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFkData
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Coordinates) == 0 {
					m.Coordinates = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Coordinates = append(m.Coordinates, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinates", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			m.Enabled = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Enabled |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Satellites", wireType)
			}
			m.Satellites = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Satellites |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hdop", wireType)
			}
			m.Hdop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hdop |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SensorReading) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SensorReading: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SensorReading: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reading", wireType)
			}
			m.Reading = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reading |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sensor", wireType)
			}
			m.Sensor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sensor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Value = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoggedReading) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoggedReading: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoggedReading: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &DeviceLocation{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reading", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reading == nil {
				m.Reading = &SensorReading{}
			}
			if err := m.Reading.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SensorAndValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SensorAndValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SensorAndValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sensor", wireType)
			}
			m.Sensor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sensor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Value = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manufacturer", wireType)
			}
			m.Manufacturer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Manufacturer |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			m.Address = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Address |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ModuleHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Firmware", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Firmware == nil {
				m.Firmware = &Firmware{}
			}
			if err := m.Firmware.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sensors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sensors = append(m.Sensors, &SensorInfo{})
			if err := m.Sensors[len(m.Sensors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = append(m.Status[:0], dAtA[iNdEx:postIndex]...)
			if m.Status == nil {
				m.Status = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SensorInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SensorInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SensorInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitOfMeasure", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnitOfMeasure = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Firmware) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Firmware: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Firmware: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Build = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Number = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = append(m.DeviceId[:0], dAtA[iNdEx:postIndex]...)
			if m.DeviceId == nil {
				m.DeviceId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Git", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Git = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetCause", wireType)
			}
			m.ResetCause = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResetCause |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sensors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sensors = append(m.Sensors, &SensorInfo{})
			if err := m.Sensors[len(m.Sensors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Modules = append(m.Modules, &ModuleInfo{})
			if err := m.Modules[len(m.Modules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Build = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Firmware", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Firmware == nil {
				m.Firmware = &Firmware{}
			}
			if err := m.Firmware.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Generation", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Generation = append(m.Generation[:0], dAtA[iNdEx:postIndex]...)
			if m.Generation == nil {
				m.Generation = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uptime", wireType)
			}
			m.Uptime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uptime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Battery", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Battery = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Busy", wireType)
			}
			m.Busy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Busy |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uptime", wireType)
			}
			m.Uptime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uptime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Facility", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Facility = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SensorGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SensorGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SensorGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			m.Module = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Module |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Readings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Readings = append(m.Readings, &SensorAndValue{})
			if err := m.Readings[len(m.Readings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Readings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Readings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Readings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reading", wireType)
			}
			m.Reading = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reading |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &DeviceLocation{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SensorGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SensorGroups = append(m.SensorGroups, &SensorGroup{})
			if err := m.SensorGroups[len(m.SensorGroups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			m.Meta = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Meta |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uptime", wireType)
			}
			m.Uptime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uptime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Interval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Interval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Interval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobSchedule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobSchedule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobSchedule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cron", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cron = append(m.Cron[:0], dAtA[iNdEx:postIndex]...)
			if m.Cron == nil {
				m.Cron = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repeated", wireType)
			}
			m.Repeated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Repeated |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jitter", wireType)
			}
			m.Jitter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Jitter |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intervals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Intervals = append(m.Intervals, &Interval{})
			if err := m.Intervals[len(m.Intervals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Schedule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Schedule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Schedule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Readings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Readings == nil {
				m.Readings = &JobSchedule{}
			}
			if err := m.Readings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Network == nil {
				m.Network = &JobSchedule{}
			}
			if err := m.Network.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lora", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lora == nil {
				m.Lora = &JobSchedule{}
			}
			if err := m.Lora.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gps == nil {
				m.Gps = &JobSchedule{}
			}
			if err := m.Gps.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Identity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Identity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Identity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Condition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Condition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Condition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recording", wireType)
			}
			m.Recording = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Recording |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ssid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ssid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Create", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Create = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preferred", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Preferred = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WifiTransmission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WifiTransmission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WifiTransmission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransmissionSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransmissionSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransmissionSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wifi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Wifi == nil {
				m.Wifi = &WifiTransmission{}
			}
			if err := m.Wifi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Networks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Networks = append(m.Networks, &NetworkInfo{})
			if err := m.Networks[len(m.Networks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoraSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoraSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoraSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceEui", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceEui = append(m.DeviceEui[:0], dAtA[iNdEx:postIndex]...)
			if m.DeviceEui == nil {
				m.DeviceEui = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppKey = append(m.AppKey[:0], dAtA[iNdEx:postIndex]...)
			if m.AppKey == nil {
				m.AppKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppEui", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppEui = append(m.AppEui[:0], dAtA[iNdEx:postIndex]...)
			if m.AppEui == nil {
				m.AppEui = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrequencyBand", wireType)
			}
			m.FrequencyBand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrequencyBand |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceAddress = append(m.DeviceAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.DeviceAddress == nil {
				m.DeviceAddress = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkSessionKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkSessionKey = append(m.NetworkSessionKey[:0], dAtA[iNdEx:postIndex]...)
			if m.NetworkSessionKey == nil {
				m.NetworkSessionKey = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppSessionKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppSessionKey = append(m.AppSessionKey[:0], dAtA[iNdEx:postIndex]...)
			if m.AppSessionKey == nil {
				m.AppSessionKey = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkCounter", wireType)
			}
			m.UplinkCounter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UplinkCounter |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownlinkCounter", wireType)
			}
			m.DownlinkCounter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownlinkCounter |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoggedReading", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LoggedReading == nil {
				m.LoggedReading = &LoggedReading{}
			}
			if err := m.LoggedReading.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Log == nil {
				m.Log = &LogMessage{}
			}
			if err := m.Log.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Readings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Readings == nil {
				m.Readings = &Readings{}
			}
			if err := m.Readings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Modules = append(m.Modules, &ModuleInfo{})
			if err := m.Modules[len(m.Modules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schedule == nil {
				m.Schedule = &Schedule{}
			}
			if err := m.Schedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			m.Meta = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Meta |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Identity == nil {
				m.Identity = &Identity{}
			}
			if err := m.Identity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Condition == nil {
				m.Condition = &Condition{}
			}
			if err := m.Condition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lora", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lora == nil {
				m.Lora = &LoraSettings{}
			}
			if err := m.Lora.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Network == nil {
				m.Network = &NetworkSettings{}
			}
			if err := m.Network.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logs = append(m.Logs, &LogMessage{})
			if err := m.Logs[len(m.Logs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transmission", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transmission == nil {
				m.Transmission = &TransmissionSettings{}
			}
			if err := m.Transmission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignedRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= SignedRecordKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Record", wireType)
			}
			m.Record = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Record |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoraRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoraRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoraRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = append(m.DeviceId[:0], dAtA[iNdEx:postIndex]...)
			if m.DeviceId == nil {
				m.DeviceId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			m.Module = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Module |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sensor", wireType)
			}
			m.Sensor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sensor |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Values = append(m.Values, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFkData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFkData
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFkData
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Values) == 0 {
					m.Values = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Values = append(m.Values, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFkData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFkData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFkData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFkData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFkData(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFkData
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFkData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFkData
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFkData
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFkData
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFkData        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFkData          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFkData = fmt.Errorf("proto: unexpected end of group")
)
