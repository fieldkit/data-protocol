// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fk-data.proto

#ifndef PROTOBUF_fk_2ddata_2eproto__INCLUDED
#define PROTOBUF_fk_2ddata_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace fk_data {
class DataRecord;
class DataRecordDefaultTypeInternal;
extern DataRecordDefaultTypeInternal _DataRecord_default_instance_;
class DeviceLocation;
class DeviceLocationDefaultTypeInternal;
extern DeviceLocationDefaultTypeInternal _DeviceLocation_default_instance_;
class Firmware;
class FirmwareDefaultTypeInternal;
extern FirmwareDefaultTypeInternal _Firmware_default_instance_;
class LogMessage;
class LogMessageDefaultTypeInternal;
extern LogMessageDefaultTypeInternal _LogMessage_default_instance_;
class LoggedReading;
class LoggedReadingDefaultTypeInternal;
extern LoggedReadingDefaultTypeInternal _LoggedReading_default_instance_;
class Metadata;
class MetadataDefaultTypeInternal;
extern MetadataDefaultTypeInternal _Metadata_default_instance_;
class ModuleInfo;
class ModuleInfoDefaultTypeInternal;
extern ModuleInfoDefaultTypeInternal _ModuleInfo_default_instance_;
class Readings;
class ReadingsDefaultTypeInternal;
extern ReadingsDefaultTypeInternal _Readings_default_instance_;
class SensorAndValue;
class SensorAndValueDefaultTypeInternal;
extern SensorAndValueDefaultTypeInternal _SensorAndValue_default_instance_;
class SensorGroup;
class SensorGroupDefaultTypeInternal;
extern SensorGroupDefaultTypeInternal _SensorGroup_default_instance_;
class SensorInfo;
class SensorInfoDefaultTypeInternal;
extern SensorInfoDefaultTypeInternal _SensorInfo_default_instance_;
class SensorReading;
class SensorReadingDefaultTypeInternal;
extern SensorReadingDefaultTypeInternal _SensorReading_default_instance_;
class Status;
class StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
}  // namespace fk_data

namespace fk_data {

namespace protobuf_fk_2ddata_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_fk_2ddata_2eproto

enum DownloadFlags {
  READING_FLAGS_NONE = 0,
  READING_FLAGS_NOT_RECORDING = 1,
  READING_FLAGS_MANUAL = 2,
  DownloadFlags_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DownloadFlags_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DownloadFlags_IsValid(int value);
const DownloadFlags DownloadFlags_MIN = READING_FLAGS_NONE;
const DownloadFlags DownloadFlags_MAX = READING_FLAGS_MANUAL;
const int DownloadFlags_ARRAYSIZE = DownloadFlags_MAX + 1;

const ::google::protobuf::EnumDescriptor* DownloadFlags_descriptor();
inline const ::std::string& DownloadFlags_Name(DownloadFlags value) {
  return ::google::protobuf::internal::NameOfEnum(
    DownloadFlags_descriptor(), value);
}
inline bool DownloadFlags_Parse(
    const ::std::string& name, DownloadFlags* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DownloadFlags>(
    DownloadFlags_descriptor(), name, value);
}
// ===================================================================

class DeviceLocation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.DeviceLocation) */ {
 public:
  DeviceLocation();
  virtual ~DeviceLocation();

  DeviceLocation(const DeviceLocation& from);

  inline DeviceLocation& operator=(const DeviceLocation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeviceLocation(DeviceLocation&& from) noexcept
    : DeviceLocation() {
    *this = ::std::move(from);
  }

  inline DeviceLocation& operator=(DeviceLocation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceLocation& default_instance();

  static inline const DeviceLocation* internal_default_instance() {
    return reinterpret_cast<const DeviceLocation*>(
               &_DeviceLocation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(DeviceLocation* other);
  friend void swap(DeviceLocation& a, DeviceLocation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeviceLocation* New() const PROTOBUF_FINAL { return New(NULL); }

  DeviceLocation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeviceLocation& from);
  void MergeFrom(const DeviceLocation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeviceLocation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float coordinates = 6;
  int coordinates_size() const;
  void clear_coordinates();
  static const int kCoordinatesFieldNumber = 6;
  float coordinates(int index) const;
  void set_coordinates(int index, float value);
  void add_coordinates(float value);
  const ::google::protobuf::RepeatedField< float >&
      coordinates() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_coordinates();

  // uint64 time = 2;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // uint32 fix = 1;
  void clear_fix();
  static const int kFixFieldNumber = 1;
  ::google::protobuf::uint32 fix() const;
  void set_fix(::google::protobuf::uint32 value);

  // float longitude = 3;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 3;
  float longitude() const;
  void set_longitude(float value);

  // float latitude = 4;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 4;
  float latitude() const;
  void set_latitude(float value);

  // float altitude = 5;
  void clear_altitude();
  static const int kAltitudeFieldNumber = 5;
  float altitude() const;
  void set_altitude(float value);

  // @@protoc_insertion_point(class_scope:fk_data.DeviceLocation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > coordinates_;
  mutable int _coordinates_cached_byte_size_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint32 fix_;
  float longitude_;
  float latitude_;
  float altitude_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SensorReading : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.SensorReading) */ {
 public:
  SensorReading();
  virtual ~SensorReading();

  SensorReading(const SensorReading& from);

  inline SensorReading& operator=(const SensorReading& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorReading(SensorReading&& from) noexcept
    : SensorReading() {
    *this = ::std::move(from);
  }

  inline SensorReading& operator=(SensorReading&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorReading& default_instance();

  static inline const SensorReading* internal_default_instance() {
    return reinterpret_cast<const SensorReading*>(
               &_SensorReading_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(SensorReading* other);
  friend void swap(SensorReading& a, SensorReading& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorReading* New() const PROTOBUF_FINAL { return New(NULL); }

  SensorReading* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SensorReading& from);
  void MergeFrom(const SensorReading& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SensorReading* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 time = 2;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // uint32 reading = 1;
  void clear_reading();
  static const int kReadingFieldNumber = 1;
  ::google::protobuf::uint32 reading() const;
  void set_reading(::google::protobuf::uint32 value);

  // uint32 sensor = 3;
  void clear_sensor();
  static const int kSensorFieldNumber = 3;
  ::google::protobuf::uint32 sensor() const;
  void set_sensor(::google::protobuf::uint32 value);

  // float value = 4;
  void clear_value();
  static const int kValueFieldNumber = 4;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:fk_data.SensorReading)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint32 reading_;
  ::google::protobuf::uint32 sensor_;
  float value_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoggedReading : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.LoggedReading) */ {
 public:
  LoggedReading();
  virtual ~LoggedReading();

  LoggedReading(const LoggedReading& from);

  inline LoggedReading& operator=(const LoggedReading& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoggedReading(LoggedReading&& from) noexcept
    : LoggedReading() {
    *this = ::std::move(from);
  }

  inline LoggedReading& operator=(LoggedReading&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoggedReading& default_instance();

  static inline const LoggedReading* internal_default_instance() {
    return reinterpret_cast<const LoggedReading*>(
               &_LoggedReading_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(LoggedReading* other);
  friend void swap(LoggedReading& a, LoggedReading& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoggedReading* New() const PROTOBUF_FINAL { return New(NULL); }

  LoggedReading* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoggedReading& from);
  void MergeFrom(const LoggedReading& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoggedReading* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .fk_data.DeviceLocation location = 2;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 2;
  const ::fk_data::DeviceLocation& location() const;
  ::fk_data::DeviceLocation* mutable_location();
  ::fk_data::DeviceLocation* release_location();
  void set_allocated_location(::fk_data::DeviceLocation* location);

  // .fk_data.SensorReading reading = 3;
  bool has_reading() const;
  void clear_reading();
  static const int kReadingFieldNumber = 3;
  const ::fk_data::SensorReading& reading() const;
  ::fk_data::SensorReading* mutable_reading();
  ::fk_data::SensorReading* release_reading();
  void set_allocated_reading(::fk_data::SensorReading* reading);

  // uint32 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fk_data.LoggedReading)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::fk_data::DeviceLocation* location_;
  ::fk_data::SensorReading* reading_;
  ::google::protobuf::uint32 version_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SensorAndValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.SensorAndValue) */ {
 public:
  SensorAndValue();
  virtual ~SensorAndValue();

  SensorAndValue(const SensorAndValue& from);

  inline SensorAndValue& operator=(const SensorAndValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorAndValue(SensorAndValue&& from) noexcept
    : SensorAndValue() {
    *this = ::std::move(from);
  }

  inline SensorAndValue& operator=(SensorAndValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorAndValue& default_instance();

  static inline const SensorAndValue* internal_default_instance() {
    return reinterpret_cast<const SensorAndValue*>(
               &_SensorAndValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(SensorAndValue* other);
  friend void swap(SensorAndValue& a, SensorAndValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorAndValue* New() const PROTOBUF_FINAL { return New(NULL); }

  SensorAndValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SensorAndValue& from);
  void MergeFrom(const SensorAndValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SensorAndValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 sensor = 1;
  void clear_sensor();
  static const int kSensorFieldNumber = 1;
  ::google::protobuf::uint32 sensor() const;
  void set_sensor(::google::protobuf::uint32 value);

  // float value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:fk_data.SensorAndValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 sensor_;
  float value_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModuleInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.ModuleInfo) */ {
 public:
  ModuleInfo();
  virtual ~ModuleInfo();

  ModuleInfo(const ModuleInfo& from);

  inline ModuleInfo& operator=(const ModuleInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModuleInfo(ModuleInfo&& from) noexcept
    : ModuleInfo() {
    *this = ::std::move(from);
  }

  inline ModuleInfo& operator=(ModuleInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleInfo& default_instance();

  static inline const ModuleInfo* internal_default_instance() {
    return reinterpret_cast<const ModuleInfo*>(
               &_ModuleInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ModuleInfo* other);
  friend void swap(ModuleInfo& a, ModuleInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModuleInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ModuleInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ModuleInfo& from);
  void MergeFrom(const ModuleInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ModuleInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 3;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // uint32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // uint32 address = 2;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  ::google::protobuf::uint32 address() const;
  void set_address(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fk_data.ModuleInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 address_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SensorInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.SensorInfo) */ {
 public:
  SensorInfo();
  virtual ~SensorInfo();

  SensorInfo(const SensorInfo& from);

  inline SensorInfo& operator=(const SensorInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorInfo(SensorInfo&& from) noexcept
    : SensorInfo() {
    *this = ::std::move(from);
  }

  inline SensorInfo& operator=(SensorInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorInfo& default_instance();

  static inline const SensorInfo* internal_default_instance() {
    return reinterpret_cast<const SensorInfo*>(
               &_SensorInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(SensorInfo* other);
  friend void swap(SensorInfo& a, SensorInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  SensorInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SensorInfo& from);
  void MergeFrom(const SensorInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SensorInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string unitOfMeasure = 3;
  void clear_unitofmeasure();
  static const int kUnitOfMeasureFieldNumber = 3;
  const ::std::string& unitofmeasure() const;
  void set_unitofmeasure(const ::std::string& value);
  #if LANG_CXX11
  void set_unitofmeasure(::std::string&& value);
  #endif
  void set_unitofmeasure(const char* value);
  void set_unitofmeasure(const char* value, size_t size);
  ::std::string* mutable_unitofmeasure();
  ::std::string* release_unitofmeasure();
  void set_allocated_unitofmeasure(::std::string* unitofmeasure);

  // uint32 sensor = 1;
  void clear_sensor();
  static const int kSensorFieldNumber = 1;
  ::google::protobuf::uint32 sensor() const;
  void set_sensor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fk_data.SensorInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr unitofmeasure_;
  ::google::protobuf::uint32 sensor_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Firmware : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.Firmware) */ {
 public:
  Firmware();
  virtual ~Firmware();

  Firmware(const Firmware& from);

  inline Firmware& operator=(const Firmware& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Firmware(Firmware&& from) noexcept
    : Firmware() {
    *this = ::std::move(from);
  }

  inline Firmware& operator=(Firmware&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Firmware& default_instance();

  static inline const Firmware* internal_default_instance() {
    return reinterpret_cast<const Firmware*>(
               &_Firmware_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Firmware* other);
  friend void swap(Firmware& a, Firmware& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Firmware* New() const PROTOBUF_FINAL { return New(NULL); }

  Firmware* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Firmware& from);
  void MergeFrom(const Firmware& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Firmware* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string git = 1;
  void clear_git();
  static const int kGitFieldNumber = 1;
  const ::std::string& git() const;
  void set_git(const ::std::string& value);
  #if LANG_CXX11
  void set_git(::std::string&& value);
  #endif
  void set_git(const char* value);
  void set_git(const char* value, size_t size);
  ::std::string* mutable_git();
  ::std::string* release_git();
  void set_allocated_git(::std::string* git);

  // string build = 2;
  void clear_build();
  static const int kBuildFieldNumber = 2;
  const ::std::string& build() const;
  void set_build(const ::std::string& value);
  #if LANG_CXX11
  void set_build(::std::string&& value);
  #endif
  void set_build(const char* value);
  void set_build(const char* value, size_t size);
  ::std::string* mutable_build();
  ::std::string* release_build();
  void set_allocated_build(::std::string* build);

  // @@protoc_insertion_point(class_scope:fk_data.Firmware)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr git_;
  ::google::protobuf::internal::ArenaStringPtr build_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Metadata : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.Metadata) */ {
 public:
  Metadata();
  virtual ~Metadata();

  Metadata(const Metadata& from);

  inline Metadata& operator=(const Metadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Metadata(Metadata&& from) noexcept
    : Metadata() {
    *this = ::std::move(from);
  }

  inline Metadata& operator=(Metadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Metadata& default_instance();

  static inline const Metadata* internal_default_instance() {
    return reinterpret_cast<const Metadata*>(
               &_Metadata_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Metadata* other);
  friend void swap(Metadata& a, Metadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Metadata* New() const PROTOBUF_FINAL { return New(NULL); }

  Metadata* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Metadata& from);
  void MergeFrom(const Metadata& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Metadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fk_data.SensorInfo sensors = 5;
  int sensors_size() const;
  void clear_sensors();
  static const int kSensorsFieldNumber = 5;
  const ::fk_data::SensorInfo& sensors(int index) const;
  ::fk_data::SensorInfo* mutable_sensors(int index);
  ::fk_data::SensorInfo* add_sensors();
  ::google::protobuf::RepeatedPtrField< ::fk_data::SensorInfo >*
      mutable_sensors();
  const ::google::protobuf::RepeatedPtrField< ::fk_data::SensorInfo >&
      sensors() const;

  // repeated .fk_data.ModuleInfo modules = 6;
  int modules_size() const;
  void clear_modules();
  static const int kModulesFieldNumber = 6;
  const ::fk_data::ModuleInfo& modules(int index) const;
  ::fk_data::ModuleInfo* mutable_modules(int index);
  ::fk_data::ModuleInfo* add_modules();
  ::google::protobuf::RepeatedPtrField< ::fk_data::ModuleInfo >*
      mutable_modules();
  const ::google::protobuf::RepeatedPtrField< ::fk_data::ModuleInfo >&
      modules() const;

  // bytes deviceId = 1;
  void clear_deviceid();
  static const int kDeviceIdFieldNumber = 1;
  const ::std::string& deviceid() const;
  void set_deviceid(const ::std::string& value);
  #if LANG_CXX11
  void set_deviceid(::std::string&& value);
  #endif
  void set_deviceid(const char* value);
  void set_deviceid(const void* value, size_t size);
  ::std::string* mutable_deviceid();
  ::std::string* release_deviceid();
  void set_allocated_deviceid(::std::string* deviceid);

  // string git = 3;
  void clear_git();
  static const int kGitFieldNumber = 3;
  const ::std::string& git() const;
  void set_git(const ::std::string& value);
  #if LANG_CXX11
  void set_git(::std::string&& value);
  #endif
  void set_git(const char* value);
  void set_git(const char* value, size_t size);
  ::std::string* mutable_git();
  ::std::string* release_git();
  void set_allocated_git(::std::string* git);

  // string build = 7;
  void clear_build();
  static const int kBuildFieldNumber = 7;
  const ::std::string& build() const;
  void set_build(const ::std::string& value);
  #if LANG_CXX11
  void set_build(::std::string&& value);
  #endif
  void set_build(const char* value);
  void set_build(const char* value, size_t size);
  ::std::string* mutable_build();
  ::std::string* release_build();
  void set_allocated_build(::std::string* build);

  // .fk_data.Firmware firmware = 8;
  bool has_firmware() const;
  void clear_firmware();
  static const int kFirmwareFieldNumber = 8;
  const ::fk_data::Firmware& firmware() const;
  ::fk_data::Firmware* mutable_firmware();
  ::fk_data::Firmware* release_firmware();
  void set_allocated_firmware(::fk_data::Firmware* firmware);

  // uint64 time = 2;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // uint32 resetCause = 4;
  void clear_resetcause();
  static const int kResetCauseFieldNumber = 4;
  ::google::protobuf::uint32 resetcause() const;
  void set_resetcause(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fk_data.Metadata)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::fk_data::SensorInfo > sensors_;
  ::google::protobuf::RepeatedPtrField< ::fk_data::ModuleInfo > modules_;
  ::google::protobuf::internal::ArenaStringPtr deviceid_;
  ::google::protobuf::internal::ArenaStringPtr git_;
  ::google::protobuf::internal::ArenaStringPtr build_;
  ::fk_data::Firmware* firmware_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint32 resetcause_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Status : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.Status) */ {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(Status&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();

  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Status* other);
  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Status* New() const PROTOBUF_FINAL { return New(NULL); }

  Status* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Status* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // uint32 uptime = 2;
  void clear_uptime();
  static const int kUptimeFieldNumber = 2;
  ::google::protobuf::uint32 uptime() const;
  void set_uptime(::google::protobuf::uint32 value);

  // float battery = 3;
  void clear_battery();
  static const int kBatteryFieldNumber = 3;
  float battery() const;
  void set_battery(float value);

  // uint64 busy = 5;
  void clear_busy();
  static const int kBusyFieldNumber = 5;
  ::google::protobuf::uint64 busy() const;
  void set_busy(::google::protobuf::uint64 value);

  // uint32 memory = 4;
  void clear_memory();
  static const int kMemoryFieldNumber = 4;
  ::google::protobuf::uint32 memory() const;
  void set_memory(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fk_data.Status)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint32 uptime_;
  float battery_;
  ::google::protobuf::uint64 busy_;
  ::google::protobuf::uint32 memory_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.LogMessage) */ {
 public:
  LogMessage();
  virtual ~LogMessage();

  LogMessage(const LogMessage& from);

  inline LogMessage& operator=(const LogMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogMessage(LogMessage&& from) noexcept
    : LogMessage() {
    *this = ::std::move(from);
  }

  inline LogMessage& operator=(LogMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogMessage& default_instance();

  static inline const LogMessage* internal_default_instance() {
    return reinterpret_cast<const LogMessage*>(
               &_LogMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(LogMessage* other);
  friend void swap(LogMessage& a, LogMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  LogMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LogMessage& from);
  void MergeFrom(const LogMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LogMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string facility = 4;
  void clear_facility();
  static const int kFacilityFieldNumber = 4;
  const ::std::string& facility() const;
  void set_facility(const ::std::string& value);
  #if LANG_CXX11
  void set_facility(::std::string&& value);
  #endif
  void set_facility(const char* value);
  void set_facility(const char* value, size_t size);
  ::std::string* mutable_facility();
  ::std::string* release_facility();
  void set_allocated_facility(::std::string* facility);

  // string message = 5;
  void clear_message();
  static const int kMessageFieldNumber = 5;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // uint64 time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // uint32 uptime = 2;
  void clear_uptime();
  static const int kUptimeFieldNumber = 2;
  ::google::protobuf::uint32 uptime() const;
  void set_uptime(::google::protobuf::uint32 value);

  // uint32 level = 3;
  void clear_level();
  static const int kLevelFieldNumber = 3;
  ::google::protobuf::uint32 level() const;
  void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fk_data.LogMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr facility_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint32 uptime_;
  ::google::protobuf::uint32 level_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SensorGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.SensorGroup) */ {
 public:
  SensorGroup();
  virtual ~SensorGroup();

  SensorGroup(const SensorGroup& from);

  inline SensorGroup& operator=(const SensorGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorGroup(SensorGroup&& from) noexcept
    : SensorGroup() {
    *this = ::std::move(from);
  }

  inline SensorGroup& operator=(SensorGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorGroup& default_instance();

  static inline const SensorGroup* internal_default_instance() {
    return reinterpret_cast<const SensorGroup*>(
               &_SensorGroup_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(SensorGroup* other);
  friend void swap(SensorGroup& a, SensorGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorGroup* New() const PROTOBUF_FINAL { return New(NULL); }

  SensorGroup* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SensorGroup& from);
  void MergeFrom(const SensorGroup& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SensorGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fk_data.SensorAndValue readings = 2;
  int readings_size() const;
  void clear_readings();
  static const int kReadingsFieldNumber = 2;
  const ::fk_data::SensorAndValue& readings(int index) const;
  ::fk_data::SensorAndValue* mutable_readings(int index);
  ::fk_data::SensorAndValue* add_readings();
  ::google::protobuf::RepeatedPtrField< ::fk_data::SensorAndValue >*
      mutable_readings();
  const ::google::protobuf::RepeatedPtrField< ::fk_data::SensorAndValue >&
      readings() const;

  // uint32 module = 1;
  void clear_module();
  static const int kModuleFieldNumber = 1;
  ::google::protobuf::uint32 module() const;
  void set_module(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fk_data.SensorGroup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::fk_data::SensorAndValue > readings_;
  ::google::protobuf::uint32 module_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Readings : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.Readings) */ {
 public:
  Readings();
  virtual ~Readings();

  Readings(const Readings& from);

  inline Readings& operator=(const Readings& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Readings(Readings&& from) noexcept
    : Readings() {
    *this = ::std::move(from);
  }

  inline Readings& operator=(Readings&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Readings& default_instance();

  static inline const Readings* internal_default_instance() {
    return reinterpret_cast<const Readings*>(
               &_Readings_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Readings* other);
  friend void swap(Readings& a, Readings& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Readings* New() const PROTOBUF_FINAL { return New(NULL); }

  Readings* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Readings& from);
  void MergeFrom(const Readings& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Readings* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fk_data.SensorGroup sensorGroups = 5;
  int sensorgroups_size() const;
  void clear_sensorgroups();
  static const int kSensorGroupsFieldNumber = 5;
  const ::fk_data::SensorGroup& sensorgroups(int index) const;
  ::fk_data::SensorGroup* mutable_sensorgroups(int index);
  ::fk_data::SensorGroup* add_sensorgroups();
  ::google::protobuf::RepeatedPtrField< ::fk_data::SensorGroup >*
      mutable_sensorgroups();
  const ::google::protobuf::RepeatedPtrField< ::fk_data::SensorGroup >&
      sensorgroups() const;

  // .fk_data.DeviceLocation location = 4;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 4;
  const ::fk_data::DeviceLocation& location() const;
  ::fk_data::DeviceLocation* mutable_location();
  ::fk_data::DeviceLocation* release_location();
  void set_allocated_location(::fk_data::DeviceLocation* location);

  // uint64 time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // uint32 reading = 2;
  void clear_reading();
  static const int kReadingFieldNumber = 2;
  ::google::protobuf::uint32 reading() const;
  void set_reading(::google::protobuf::uint32 value);

  // uint32 flags = 3;
  void clear_flags();
  static const int kFlagsFieldNumber = 3;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fk_data.Readings)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::fk_data::SensorGroup > sensorgroups_;
  ::fk_data::DeviceLocation* location_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint32 reading_;
  ::google::protobuf::uint32 flags_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DataRecord : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.DataRecord) */ {
 public:
  DataRecord();
  virtual ~DataRecord();

  DataRecord(const DataRecord& from);

  inline DataRecord& operator=(const DataRecord& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DataRecord(DataRecord&& from) noexcept
    : DataRecord() {
    *this = ::std::move(from);
  }

  inline DataRecord& operator=(DataRecord&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DataRecord& default_instance();

  static inline const DataRecord* internal_default_instance() {
    return reinterpret_cast<const DataRecord*>(
               &_DataRecord_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(DataRecord* other);
  friend void swap(DataRecord& a, DataRecord& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DataRecord* New() const PROTOBUF_FINAL { return New(NULL); }

  DataRecord* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DataRecord& from);
  void MergeFrom(const DataRecord& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DataRecord* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .fk_data.LoggedReading loggedReading = 1;
  bool has_loggedreading() const;
  void clear_loggedreading();
  static const int kLoggedReadingFieldNumber = 1;
  const ::fk_data::LoggedReading& loggedreading() const;
  ::fk_data::LoggedReading* mutable_loggedreading();
  ::fk_data::LoggedReading* release_loggedreading();
  void set_allocated_loggedreading(::fk_data::LoggedReading* loggedreading);

  // .fk_data.Metadata metadata = 2;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 2;
  const ::fk_data::Metadata& metadata() const;
  ::fk_data::Metadata* mutable_metadata();
  ::fk_data::Metadata* release_metadata();
  void set_allocated_metadata(::fk_data::Metadata* metadata);

  // .fk_data.LogMessage log = 3;
  bool has_log() const;
  void clear_log();
  static const int kLogFieldNumber = 3;
  const ::fk_data::LogMessage& log() const;
  ::fk_data::LogMessage* mutable_log();
  ::fk_data::LogMessage* release_log();
  void set_allocated_log(::fk_data::LogMessage* log);

  // .fk_data.Status status = 4;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  const ::fk_data::Status& status() const;
  ::fk_data::Status* mutable_status();
  ::fk_data::Status* release_status();
  void set_allocated_status(::fk_data::Status* status);

  // .fk_data.Readings readings = 5;
  bool has_readings() const;
  void clear_readings();
  static const int kReadingsFieldNumber = 5;
  const ::fk_data::Readings& readings() const;
  ::fk_data::Readings* mutable_readings();
  ::fk_data::Readings* release_readings();
  void set_allocated_readings(::fk_data::Readings* readings);

  // @@protoc_insertion_point(class_scope:fk_data.DataRecord)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::fk_data::LoggedReading* loggedreading_;
  ::fk_data::Metadata* metadata_;
  ::fk_data::LogMessage* log_;
  ::fk_data::Status* status_;
  ::fk_data::Readings* readings_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DeviceLocation

// uint32 fix = 1;
inline void DeviceLocation::clear_fix() {
  fix_ = 0u;
}
inline ::google::protobuf::uint32 DeviceLocation::fix() const {
  // @@protoc_insertion_point(field_get:fk_data.DeviceLocation.fix)
  return fix_;
}
inline void DeviceLocation::set_fix(::google::protobuf::uint32 value) {
  
  fix_ = value;
  // @@protoc_insertion_point(field_set:fk_data.DeviceLocation.fix)
}

// uint64 time = 2;
inline void DeviceLocation::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 DeviceLocation::time() const {
  // @@protoc_insertion_point(field_get:fk_data.DeviceLocation.time)
  return time_;
}
inline void DeviceLocation::set_time(::google::protobuf::uint64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:fk_data.DeviceLocation.time)
}

// float longitude = 3;
inline void DeviceLocation::clear_longitude() {
  longitude_ = 0;
}
inline float DeviceLocation::longitude() const {
  // @@protoc_insertion_point(field_get:fk_data.DeviceLocation.longitude)
  return longitude_;
}
inline void DeviceLocation::set_longitude(float value) {
  
  longitude_ = value;
  // @@protoc_insertion_point(field_set:fk_data.DeviceLocation.longitude)
}

// float latitude = 4;
inline void DeviceLocation::clear_latitude() {
  latitude_ = 0;
}
inline float DeviceLocation::latitude() const {
  // @@protoc_insertion_point(field_get:fk_data.DeviceLocation.latitude)
  return latitude_;
}
inline void DeviceLocation::set_latitude(float value) {
  
  latitude_ = value;
  // @@protoc_insertion_point(field_set:fk_data.DeviceLocation.latitude)
}

// float altitude = 5;
inline void DeviceLocation::clear_altitude() {
  altitude_ = 0;
}
inline float DeviceLocation::altitude() const {
  // @@protoc_insertion_point(field_get:fk_data.DeviceLocation.altitude)
  return altitude_;
}
inline void DeviceLocation::set_altitude(float value) {
  
  altitude_ = value;
  // @@protoc_insertion_point(field_set:fk_data.DeviceLocation.altitude)
}

// repeated float coordinates = 6;
inline int DeviceLocation::coordinates_size() const {
  return coordinates_.size();
}
inline void DeviceLocation::clear_coordinates() {
  coordinates_.Clear();
}
inline float DeviceLocation::coordinates(int index) const {
  // @@protoc_insertion_point(field_get:fk_data.DeviceLocation.coordinates)
  return coordinates_.Get(index);
}
inline void DeviceLocation::set_coordinates(int index, float value) {
  coordinates_.Set(index, value);
  // @@protoc_insertion_point(field_set:fk_data.DeviceLocation.coordinates)
}
inline void DeviceLocation::add_coordinates(float value) {
  coordinates_.Add(value);
  // @@protoc_insertion_point(field_add:fk_data.DeviceLocation.coordinates)
}
inline const ::google::protobuf::RepeatedField< float >&
DeviceLocation::coordinates() const {
  // @@protoc_insertion_point(field_list:fk_data.DeviceLocation.coordinates)
  return coordinates_;
}
inline ::google::protobuf::RepeatedField< float >*
DeviceLocation::mutable_coordinates() {
  // @@protoc_insertion_point(field_mutable_list:fk_data.DeviceLocation.coordinates)
  return &coordinates_;
}

// -------------------------------------------------------------------

// SensorReading

// uint32 reading = 1;
inline void SensorReading::clear_reading() {
  reading_ = 0u;
}
inline ::google::protobuf::uint32 SensorReading::reading() const {
  // @@protoc_insertion_point(field_get:fk_data.SensorReading.reading)
  return reading_;
}
inline void SensorReading::set_reading(::google::protobuf::uint32 value) {
  
  reading_ = value;
  // @@protoc_insertion_point(field_set:fk_data.SensorReading.reading)
}

// uint64 time = 2;
inline void SensorReading::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SensorReading::time() const {
  // @@protoc_insertion_point(field_get:fk_data.SensorReading.time)
  return time_;
}
inline void SensorReading::set_time(::google::protobuf::uint64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:fk_data.SensorReading.time)
}

// uint32 sensor = 3;
inline void SensorReading::clear_sensor() {
  sensor_ = 0u;
}
inline ::google::protobuf::uint32 SensorReading::sensor() const {
  // @@protoc_insertion_point(field_get:fk_data.SensorReading.sensor)
  return sensor_;
}
inline void SensorReading::set_sensor(::google::protobuf::uint32 value) {
  
  sensor_ = value;
  // @@protoc_insertion_point(field_set:fk_data.SensorReading.sensor)
}

// float value = 4;
inline void SensorReading::clear_value() {
  value_ = 0;
}
inline float SensorReading::value() const {
  // @@protoc_insertion_point(field_get:fk_data.SensorReading.value)
  return value_;
}
inline void SensorReading::set_value(float value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:fk_data.SensorReading.value)
}

// -------------------------------------------------------------------

// LoggedReading

// uint32 version = 1;
inline void LoggedReading::clear_version() {
  version_ = 0u;
}
inline ::google::protobuf::uint32 LoggedReading::version() const {
  // @@protoc_insertion_point(field_get:fk_data.LoggedReading.version)
  return version_;
}
inline void LoggedReading::set_version(::google::protobuf::uint32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:fk_data.LoggedReading.version)
}

// .fk_data.DeviceLocation location = 2;
inline bool LoggedReading::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void LoggedReading::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
inline const ::fk_data::DeviceLocation& LoggedReading::location() const {
  const ::fk_data::DeviceLocation* p = location_;
  // @@protoc_insertion_point(field_get:fk_data.LoggedReading.location)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::DeviceLocation*>(
      &::fk_data::_DeviceLocation_default_instance_);
}
inline ::fk_data::DeviceLocation* LoggedReading::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::fk_data::DeviceLocation;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.LoggedReading.location)
  return location_;
}
inline ::fk_data::DeviceLocation* LoggedReading::release_location() {
  // @@protoc_insertion_point(field_release:fk_data.LoggedReading.location)
  
  ::fk_data::DeviceLocation* temp = location_;
  location_ = NULL;
  return temp;
}
inline void LoggedReading::set_allocated_location(::fk_data::DeviceLocation* location) {
  delete location_;
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.LoggedReading.location)
}

// .fk_data.SensorReading reading = 3;
inline bool LoggedReading::has_reading() const {
  return this != internal_default_instance() && reading_ != NULL;
}
inline void LoggedReading::clear_reading() {
  if (GetArenaNoVirtual() == NULL && reading_ != NULL) delete reading_;
  reading_ = NULL;
}
inline const ::fk_data::SensorReading& LoggedReading::reading() const {
  const ::fk_data::SensorReading* p = reading_;
  // @@protoc_insertion_point(field_get:fk_data.LoggedReading.reading)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::SensorReading*>(
      &::fk_data::_SensorReading_default_instance_);
}
inline ::fk_data::SensorReading* LoggedReading::mutable_reading() {
  
  if (reading_ == NULL) {
    reading_ = new ::fk_data::SensorReading;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.LoggedReading.reading)
  return reading_;
}
inline ::fk_data::SensorReading* LoggedReading::release_reading() {
  // @@protoc_insertion_point(field_release:fk_data.LoggedReading.reading)
  
  ::fk_data::SensorReading* temp = reading_;
  reading_ = NULL;
  return temp;
}
inline void LoggedReading::set_allocated_reading(::fk_data::SensorReading* reading) {
  delete reading_;
  reading_ = reading;
  if (reading) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.LoggedReading.reading)
}

// -------------------------------------------------------------------

// SensorAndValue

// uint32 sensor = 1;
inline void SensorAndValue::clear_sensor() {
  sensor_ = 0u;
}
inline ::google::protobuf::uint32 SensorAndValue::sensor() const {
  // @@protoc_insertion_point(field_get:fk_data.SensorAndValue.sensor)
  return sensor_;
}
inline void SensorAndValue::set_sensor(::google::protobuf::uint32 value) {
  
  sensor_ = value;
  // @@protoc_insertion_point(field_set:fk_data.SensorAndValue.sensor)
}

// float value = 2;
inline void SensorAndValue::clear_value() {
  value_ = 0;
}
inline float SensorAndValue::value() const {
  // @@protoc_insertion_point(field_get:fk_data.SensorAndValue.value)
  return value_;
}
inline void SensorAndValue::set_value(float value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:fk_data.SensorAndValue.value)
}

// -------------------------------------------------------------------

// ModuleInfo

// uint32 id = 1;
inline void ModuleInfo::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 ModuleInfo::id() const {
  // @@protoc_insertion_point(field_get:fk_data.ModuleInfo.id)
  return id_;
}
inline void ModuleInfo::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:fk_data.ModuleInfo.id)
}

// uint32 address = 2;
inline void ModuleInfo::clear_address() {
  address_ = 0u;
}
inline ::google::protobuf::uint32 ModuleInfo::address() const {
  // @@protoc_insertion_point(field_get:fk_data.ModuleInfo.address)
  return address_;
}
inline void ModuleInfo::set_address(::google::protobuf::uint32 value) {
  
  address_ = value;
  // @@protoc_insertion_point(field_set:fk_data.ModuleInfo.address)
}

// string name = 3;
inline void ModuleInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ModuleInfo::name() const {
  // @@protoc_insertion_point(field_get:fk_data.ModuleInfo.name)
  return name_.GetNoArena();
}
inline void ModuleInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.ModuleInfo.name)
}
#if LANG_CXX11
inline void ModuleInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.ModuleInfo.name)
}
#endif
inline void ModuleInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.ModuleInfo.name)
}
inline void ModuleInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.ModuleInfo.name)
}
inline ::std::string* ModuleInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.ModuleInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModuleInfo::release_name() {
  // @@protoc_insertion_point(field_release:fk_data.ModuleInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModuleInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:fk_data.ModuleInfo.name)
}

// -------------------------------------------------------------------

// SensorInfo

// uint32 sensor = 1;
inline void SensorInfo::clear_sensor() {
  sensor_ = 0u;
}
inline ::google::protobuf::uint32 SensorInfo::sensor() const {
  // @@protoc_insertion_point(field_get:fk_data.SensorInfo.sensor)
  return sensor_;
}
inline void SensorInfo::set_sensor(::google::protobuf::uint32 value) {
  
  sensor_ = value;
  // @@protoc_insertion_point(field_set:fk_data.SensorInfo.sensor)
}

// string name = 2;
inline void SensorInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SensorInfo::name() const {
  // @@protoc_insertion_point(field_get:fk_data.SensorInfo.name)
  return name_.GetNoArena();
}
inline void SensorInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.SensorInfo.name)
}
#if LANG_CXX11
inline void SensorInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.SensorInfo.name)
}
#endif
inline void SensorInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.SensorInfo.name)
}
inline void SensorInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.SensorInfo.name)
}
inline ::std::string* SensorInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.SensorInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SensorInfo::release_name() {
  // @@protoc_insertion_point(field_release:fk_data.SensorInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SensorInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:fk_data.SensorInfo.name)
}

// string unitOfMeasure = 3;
inline void SensorInfo::clear_unitofmeasure() {
  unitofmeasure_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SensorInfo::unitofmeasure() const {
  // @@protoc_insertion_point(field_get:fk_data.SensorInfo.unitOfMeasure)
  return unitofmeasure_.GetNoArena();
}
inline void SensorInfo::set_unitofmeasure(const ::std::string& value) {
  
  unitofmeasure_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.SensorInfo.unitOfMeasure)
}
#if LANG_CXX11
inline void SensorInfo::set_unitofmeasure(::std::string&& value) {
  
  unitofmeasure_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.SensorInfo.unitOfMeasure)
}
#endif
inline void SensorInfo::set_unitofmeasure(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  unitofmeasure_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.SensorInfo.unitOfMeasure)
}
inline void SensorInfo::set_unitofmeasure(const char* value, size_t size) {
  
  unitofmeasure_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.SensorInfo.unitOfMeasure)
}
inline ::std::string* SensorInfo::mutable_unitofmeasure() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.SensorInfo.unitOfMeasure)
  return unitofmeasure_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SensorInfo::release_unitofmeasure() {
  // @@protoc_insertion_point(field_release:fk_data.SensorInfo.unitOfMeasure)
  
  return unitofmeasure_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SensorInfo::set_allocated_unitofmeasure(::std::string* unitofmeasure) {
  if (unitofmeasure != NULL) {
    
  } else {
    
  }
  unitofmeasure_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), unitofmeasure);
  // @@protoc_insertion_point(field_set_allocated:fk_data.SensorInfo.unitOfMeasure)
}

// -------------------------------------------------------------------

// Firmware

// string git = 1;
inline void Firmware::clear_git() {
  git_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Firmware::git() const {
  // @@protoc_insertion_point(field_get:fk_data.Firmware.git)
  return git_.GetNoArena();
}
inline void Firmware::set_git(const ::std::string& value) {
  
  git_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.Firmware.git)
}
#if LANG_CXX11
inline void Firmware::set_git(::std::string&& value) {
  
  git_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.Firmware.git)
}
#endif
inline void Firmware::set_git(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  git_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.Firmware.git)
}
inline void Firmware::set_git(const char* value, size_t size) {
  
  git_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.Firmware.git)
}
inline ::std::string* Firmware::mutable_git() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.Firmware.git)
  return git_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Firmware::release_git() {
  // @@protoc_insertion_point(field_release:fk_data.Firmware.git)
  
  return git_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Firmware::set_allocated_git(::std::string* git) {
  if (git != NULL) {
    
  } else {
    
  }
  git_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), git);
  // @@protoc_insertion_point(field_set_allocated:fk_data.Firmware.git)
}

// string build = 2;
inline void Firmware::clear_build() {
  build_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Firmware::build() const {
  // @@protoc_insertion_point(field_get:fk_data.Firmware.build)
  return build_.GetNoArena();
}
inline void Firmware::set_build(const ::std::string& value) {
  
  build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.Firmware.build)
}
#if LANG_CXX11
inline void Firmware::set_build(::std::string&& value) {
  
  build_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.Firmware.build)
}
#endif
inline void Firmware::set_build(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.Firmware.build)
}
inline void Firmware::set_build(const char* value, size_t size) {
  
  build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.Firmware.build)
}
inline ::std::string* Firmware::mutable_build() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.Firmware.build)
  return build_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Firmware::release_build() {
  // @@protoc_insertion_point(field_release:fk_data.Firmware.build)
  
  return build_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Firmware::set_allocated_build(::std::string* build) {
  if (build != NULL) {
    
  } else {
    
  }
  build_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), build);
  // @@protoc_insertion_point(field_set_allocated:fk_data.Firmware.build)
}

// -------------------------------------------------------------------

// Metadata

// bytes deviceId = 1;
inline void Metadata::clear_deviceid() {
  deviceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Metadata::deviceid() const {
  // @@protoc_insertion_point(field_get:fk_data.Metadata.deviceId)
  return deviceid_.GetNoArena();
}
inline void Metadata::set_deviceid(const ::std::string& value) {
  
  deviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.Metadata.deviceId)
}
#if LANG_CXX11
inline void Metadata::set_deviceid(::std::string&& value) {
  
  deviceid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.Metadata.deviceId)
}
#endif
inline void Metadata::set_deviceid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  deviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.Metadata.deviceId)
}
inline void Metadata::set_deviceid(const void* value, size_t size) {
  
  deviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.Metadata.deviceId)
}
inline ::std::string* Metadata::mutable_deviceid() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.Metadata.deviceId)
  return deviceid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Metadata::release_deviceid() {
  // @@protoc_insertion_point(field_release:fk_data.Metadata.deviceId)
  
  return deviceid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Metadata::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid != NULL) {
    
  } else {
    
  }
  deviceid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), deviceid);
  // @@protoc_insertion_point(field_set_allocated:fk_data.Metadata.deviceId)
}

// uint64 time = 2;
inline void Metadata::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Metadata::time() const {
  // @@protoc_insertion_point(field_get:fk_data.Metadata.time)
  return time_;
}
inline void Metadata::set_time(::google::protobuf::uint64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:fk_data.Metadata.time)
}

// string git = 3;
inline void Metadata::clear_git() {
  git_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Metadata::git() const {
  // @@protoc_insertion_point(field_get:fk_data.Metadata.git)
  return git_.GetNoArena();
}
inline void Metadata::set_git(const ::std::string& value) {
  
  git_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.Metadata.git)
}
#if LANG_CXX11
inline void Metadata::set_git(::std::string&& value) {
  
  git_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.Metadata.git)
}
#endif
inline void Metadata::set_git(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  git_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.Metadata.git)
}
inline void Metadata::set_git(const char* value, size_t size) {
  
  git_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.Metadata.git)
}
inline ::std::string* Metadata::mutable_git() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.Metadata.git)
  return git_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Metadata::release_git() {
  // @@protoc_insertion_point(field_release:fk_data.Metadata.git)
  
  return git_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Metadata::set_allocated_git(::std::string* git) {
  if (git != NULL) {
    
  } else {
    
  }
  git_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), git);
  // @@protoc_insertion_point(field_set_allocated:fk_data.Metadata.git)
}

// string build = 7;
inline void Metadata::clear_build() {
  build_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Metadata::build() const {
  // @@protoc_insertion_point(field_get:fk_data.Metadata.build)
  return build_.GetNoArena();
}
inline void Metadata::set_build(const ::std::string& value) {
  
  build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.Metadata.build)
}
#if LANG_CXX11
inline void Metadata::set_build(::std::string&& value) {
  
  build_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.Metadata.build)
}
#endif
inline void Metadata::set_build(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.Metadata.build)
}
inline void Metadata::set_build(const char* value, size_t size) {
  
  build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.Metadata.build)
}
inline ::std::string* Metadata::mutable_build() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.Metadata.build)
  return build_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Metadata::release_build() {
  // @@protoc_insertion_point(field_release:fk_data.Metadata.build)
  
  return build_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Metadata::set_allocated_build(::std::string* build) {
  if (build != NULL) {
    
  } else {
    
  }
  build_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), build);
  // @@protoc_insertion_point(field_set_allocated:fk_data.Metadata.build)
}

// uint32 resetCause = 4;
inline void Metadata::clear_resetcause() {
  resetcause_ = 0u;
}
inline ::google::protobuf::uint32 Metadata::resetcause() const {
  // @@protoc_insertion_point(field_get:fk_data.Metadata.resetCause)
  return resetcause_;
}
inline void Metadata::set_resetcause(::google::protobuf::uint32 value) {
  
  resetcause_ = value;
  // @@protoc_insertion_point(field_set:fk_data.Metadata.resetCause)
}

// repeated .fk_data.SensorInfo sensors = 5;
inline int Metadata::sensors_size() const {
  return sensors_.size();
}
inline void Metadata::clear_sensors() {
  sensors_.Clear();
}
inline const ::fk_data::SensorInfo& Metadata::sensors(int index) const {
  // @@protoc_insertion_point(field_get:fk_data.Metadata.sensors)
  return sensors_.Get(index);
}
inline ::fk_data::SensorInfo* Metadata::mutable_sensors(int index) {
  // @@protoc_insertion_point(field_mutable:fk_data.Metadata.sensors)
  return sensors_.Mutable(index);
}
inline ::fk_data::SensorInfo* Metadata::add_sensors() {
  // @@protoc_insertion_point(field_add:fk_data.Metadata.sensors)
  return sensors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fk_data::SensorInfo >*
Metadata::mutable_sensors() {
  // @@protoc_insertion_point(field_mutable_list:fk_data.Metadata.sensors)
  return &sensors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fk_data::SensorInfo >&
Metadata::sensors() const {
  // @@protoc_insertion_point(field_list:fk_data.Metadata.sensors)
  return sensors_;
}

// repeated .fk_data.ModuleInfo modules = 6;
inline int Metadata::modules_size() const {
  return modules_.size();
}
inline void Metadata::clear_modules() {
  modules_.Clear();
}
inline const ::fk_data::ModuleInfo& Metadata::modules(int index) const {
  // @@protoc_insertion_point(field_get:fk_data.Metadata.modules)
  return modules_.Get(index);
}
inline ::fk_data::ModuleInfo* Metadata::mutable_modules(int index) {
  // @@protoc_insertion_point(field_mutable:fk_data.Metadata.modules)
  return modules_.Mutable(index);
}
inline ::fk_data::ModuleInfo* Metadata::add_modules() {
  // @@protoc_insertion_point(field_add:fk_data.Metadata.modules)
  return modules_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fk_data::ModuleInfo >*
Metadata::mutable_modules() {
  // @@protoc_insertion_point(field_mutable_list:fk_data.Metadata.modules)
  return &modules_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fk_data::ModuleInfo >&
Metadata::modules() const {
  // @@protoc_insertion_point(field_list:fk_data.Metadata.modules)
  return modules_;
}

// .fk_data.Firmware firmware = 8;
inline bool Metadata::has_firmware() const {
  return this != internal_default_instance() && firmware_ != NULL;
}
inline void Metadata::clear_firmware() {
  if (GetArenaNoVirtual() == NULL && firmware_ != NULL) delete firmware_;
  firmware_ = NULL;
}
inline const ::fk_data::Firmware& Metadata::firmware() const {
  const ::fk_data::Firmware* p = firmware_;
  // @@protoc_insertion_point(field_get:fk_data.Metadata.firmware)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::Firmware*>(
      &::fk_data::_Firmware_default_instance_);
}
inline ::fk_data::Firmware* Metadata::mutable_firmware() {
  
  if (firmware_ == NULL) {
    firmware_ = new ::fk_data::Firmware;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.Metadata.firmware)
  return firmware_;
}
inline ::fk_data::Firmware* Metadata::release_firmware() {
  // @@protoc_insertion_point(field_release:fk_data.Metadata.firmware)
  
  ::fk_data::Firmware* temp = firmware_;
  firmware_ = NULL;
  return temp;
}
inline void Metadata::set_allocated_firmware(::fk_data::Firmware* firmware) {
  delete firmware_;
  firmware_ = firmware;
  if (firmware) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.Metadata.firmware)
}

// -------------------------------------------------------------------

// Status

// uint64 time = 1;
inline void Status::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Status::time() const {
  // @@protoc_insertion_point(field_get:fk_data.Status.time)
  return time_;
}
inline void Status::set_time(::google::protobuf::uint64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:fk_data.Status.time)
}

// uint32 uptime = 2;
inline void Status::clear_uptime() {
  uptime_ = 0u;
}
inline ::google::protobuf::uint32 Status::uptime() const {
  // @@protoc_insertion_point(field_get:fk_data.Status.uptime)
  return uptime_;
}
inline void Status::set_uptime(::google::protobuf::uint32 value) {
  
  uptime_ = value;
  // @@protoc_insertion_point(field_set:fk_data.Status.uptime)
}

// float battery = 3;
inline void Status::clear_battery() {
  battery_ = 0;
}
inline float Status::battery() const {
  // @@protoc_insertion_point(field_get:fk_data.Status.battery)
  return battery_;
}
inline void Status::set_battery(float value) {
  
  battery_ = value;
  // @@protoc_insertion_point(field_set:fk_data.Status.battery)
}

// uint32 memory = 4;
inline void Status::clear_memory() {
  memory_ = 0u;
}
inline ::google::protobuf::uint32 Status::memory() const {
  // @@protoc_insertion_point(field_get:fk_data.Status.memory)
  return memory_;
}
inline void Status::set_memory(::google::protobuf::uint32 value) {
  
  memory_ = value;
  // @@protoc_insertion_point(field_set:fk_data.Status.memory)
}

// uint64 busy = 5;
inline void Status::clear_busy() {
  busy_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Status::busy() const {
  // @@protoc_insertion_point(field_get:fk_data.Status.busy)
  return busy_;
}
inline void Status::set_busy(::google::protobuf::uint64 value) {
  
  busy_ = value;
  // @@protoc_insertion_point(field_set:fk_data.Status.busy)
}

// -------------------------------------------------------------------

// LogMessage

// uint64 time = 1;
inline void LogMessage::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 LogMessage::time() const {
  // @@protoc_insertion_point(field_get:fk_data.LogMessage.time)
  return time_;
}
inline void LogMessage::set_time(::google::protobuf::uint64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:fk_data.LogMessage.time)
}

// uint32 uptime = 2;
inline void LogMessage::clear_uptime() {
  uptime_ = 0u;
}
inline ::google::protobuf::uint32 LogMessage::uptime() const {
  // @@protoc_insertion_point(field_get:fk_data.LogMessage.uptime)
  return uptime_;
}
inline void LogMessage::set_uptime(::google::protobuf::uint32 value) {
  
  uptime_ = value;
  // @@protoc_insertion_point(field_set:fk_data.LogMessage.uptime)
}

// uint32 level = 3;
inline void LogMessage::clear_level() {
  level_ = 0u;
}
inline ::google::protobuf::uint32 LogMessage::level() const {
  // @@protoc_insertion_point(field_get:fk_data.LogMessage.level)
  return level_;
}
inline void LogMessage::set_level(::google::protobuf::uint32 value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:fk_data.LogMessage.level)
}

// string facility = 4;
inline void LogMessage::clear_facility() {
  facility_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogMessage::facility() const {
  // @@protoc_insertion_point(field_get:fk_data.LogMessage.facility)
  return facility_.GetNoArena();
}
inline void LogMessage::set_facility(const ::std::string& value) {
  
  facility_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.LogMessage.facility)
}
#if LANG_CXX11
inline void LogMessage::set_facility(::std::string&& value) {
  
  facility_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.LogMessage.facility)
}
#endif
inline void LogMessage::set_facility(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  facility_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.LogMessage.facility)
}
inline void LogMessage::set_facility(const char* value, size_t size) {
  
  facility_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.LogMessage.facility)
}
inline ::std::string* LogMessage::mutable_facility() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.LogMessage.facility)
  return facility_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogMessage::release_facility() {
  // @@protoc_insertion_point(field_release:fk_data.LogMessage.facility)
  
  return facility_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogMessage::set_allocated_facility(::std::string* facility) {
  if (facility != NULL) {
    
  } else {
    
  }
  facility_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), facility);
  // @@protoc_insertion_point(field_set_allocated:fk_data.LogMessage.facility)
}

// string message = 5;
inline void LogMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogMessage::message() const {
  // @@protoc_insertion_point(field_get:fk_data.LogMessage.message)
  return message_.GetNoArena();
}
inline void LogMessage::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.LogMessage.message)
}
#if LANG_CXX11
inline void LogMessage::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.LogMessage.message)
}
#endif
inline void LogMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.LogMessage.message)
}
inline void LogMessage::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.LogMessage.message)
}
inline ::std::string* LogMessage::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.LogMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogMessage::release_message() {
  // @@protoc_insertion_point(field_release:fk_data.LogMessage.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:fk_data.LogMessage.message)
}

// -------------------------------------------------------------------

// SensorGroup

// uint32 module = 1;
inline void SensorGroup::clear_module() {
  module_ = 0u;
}
inline ::google::protobuf::uint32 SensorGroup::module() const {
  // @@protoc_insertion_point(field_get:fk_data.SensorGroup.module)
  return module_;
}
inline void SensorGroup::set_module(::google::protobuf::uint32 value) {
  
  module_ = value;
  // @@protoc_insertion_point(field_set:fk_data.SensorGroup.module)
}

// repeated .fk_data.SensorAndValue readings = 2;
inline int SensorGroup::readings_size() const {
  return readings_.size();
}
inline void SensorGroup::clear_readings() {
  readings_.Clear();
}
inline const ::fk_data::SensorAndValue& SensorGroup::readings(int index) const {
  // @@protoc_insertion_point(field_get:fk_data.SensorGroup.readings)
  return readings_.Get(index);
}
inline ::fk_data::SensorAndValue* SensorGroup::mutable_readings(int index) {
  // @@protoc_insertion_point(field_mutable:fk_data.SensorGroup.readings)
  return readings_.Mutable(index);
}
inline ::fk_data::SensorAndValue* SensorGroup::add_readings() {
  // @@protoc_insertion_point(field_add:fk_data.SensorGroup.readings)
  return readings_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fk_data::SensorAndValue >*
SensorGroup::mutable_readings() {
  // @@protoc_insertion_point(field_mutable_list:fk_data.SensorGroup.readings)
  return &readings_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fk_data::SensorAndValue >&
SensorGroup::readings() const {
  // @@protoc_insertion_point(field_list:fk_data.SensorGroup.readings)
  return readings_;
}

// -------------------------------------------------------------------

// Readings

// uint64 time = 1;
inline void Readings::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Readings::time() const {
  // @@protoc_insertion_point(field_get:fk_data.Readings.time)
  return time_;
}
inline void Readings::set_time(::google::protobuf::uint64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:fk_data.Readings.time)
}

// uint32 reading = 2;
inline void Readings::clear_reading() {
  reading_ = 0u;
}
inline ::google::protobuf::uint32 Readings::reading() const {
  // @@protoc_insertion_point(field_get:fk_data.Readings.reading)
  return reading_;
}
inline void Readings::set_reading(::google::protobuf::uint32 value) {
  
  reading_ = value;
  // @@protoc_insertion_point(field_set:fk_data.Readings.reading)
}

// uint32 flags = 3;
inline void Readings::clear_flags() {
  flags_ = 0u;
}
inline ::google::protobuf::uint32 Readings::flags() const {
  // @@protoc_insertion_point(field_get:fk_data.Readings.flags)
  return flags_;
}
inline void Readings::set_flags(::google::protobuf::uint32 value) {
  
  flags_ = value;
  // @@protoc_insertion_point(field_set:fk_data.Readings.flags)
}

// .fk_data.DeviceLocation location = 4;
inline bool Readings::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void Readings::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
inline const ::fk_data::DeviceLocation& Readings::location() const {
  const ::fk_data::DeviceLocation* p = location_;
  // @@protoc_insertion_point(field_get:fk_data.Readings.location)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::DeviceLocation*>(
      &::fk_data::_DeviceLocation_default_instance_);
}
inline ::fk_data::DeviceLocation* Readings::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::fk_data::DeviceLocation;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.Readings.location)
  return location_;
}
inline ::fk_data::DeviceLocation* Readings::release_location() {
  // @@protoc_insertion_point(field_release:fk_data.Readings.location)
  
  ::fk_data::DeviceLocation* temp = location_;
  location_ = NULL;
  return temp;
}
inline void Readings::set_allocated_location(::fk_data::DeviceLocation* location) {
  delete location_;
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.Readings.location)
}

// repeated .fk_data.SensorGroup sensorGroups = 5;
inline int Readings::sensorgroups_size() const {
  return sensorgroups_.size();
}
inline void Readings::clear_sensorgroups() {
  sensorgroups_.Clear();
}
inline const ::fk_data::SensorGroup& Readings::sensorgroups(int index) const {
  // @@protoc_insertion_point(field_get:fk_data.Readings.sensorGroups)
  return sensorgroups_.Get(index);
}
inline ::fk_data::SensorGroup* Readings::mutable_sensorgroups(int index) {
  // @@protoc_insertion_point(field_mutable:fk_data.Readings.sensorGroups)
  return sensorgroups_.Mutable(index);
}
inline ::fk_data::SensorGroup* Readings::add_sensorgroups() {
  // @@protoc_insertion_point(field_add:fk_data.Readings.sensorGroups)
  return sensorgroups_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fk_data::SensorGroup >*
Readings::mutable_sensorgroups() {
  // @@protoc_insertion_point(field_mutable_list:fk_data.Readings.sensorGroups)
  return &sensorgroups_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fk_data::SensorGroup >&
Readings::sensorgroups() const {
  // @@protoc_insertion_point(field_list:fk_data.Readings.sensorGroups)
  return sensorgroups_;
}

// -------------------------------------------------------------------

// DataRecord

// .fk_data.LoggedReading loggedReading = 1;
inline bool DataRecord::has_loggedreading() const {
  return this != internal_default_instance() && loggedreading_ != NULL;
}
inline void DataRecord::clear_loggedreading() {
  if (GetArenaNoVirtual() == NULL && loggedreading_ != NULL) delete loggedreading_;
  loggedreading_ = NULL;
}
inline const ::fk_data::LoggedReading& DataRecord::loggedreading() const {
  const ::fk_data::LoggedReading* p = loggedreading_;
  // @@protoc_insertion_point(field_get:fk_data.DataRecord.loggedReading)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::LoggedReading*>(
      &::fk_data::_LoggedReading_default_instance_);
}
inline ::fk_data::LoggedReading* DataRecord::mutable_loggedreading() {
  
  if (loggedreading_ == NULL) {
    loggedreading_ = new ::fk_data::LoggedReading;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.DataRecord.loggedReading)
  return loggedreading_;
}
inline ::fk_data::LoggedReading* DataRecord::release_loggedreading() {
  // @@protoc_insertion_point(field_release:fk_data.DataRecord.loggedReading)
  
  ::fk_data::LoggedReading* temp = loggedreading_;
  loggedreading_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_loggedreading(::fk_data::LoggedReading* loggedreading) {
  delete loggedreading_;
  loggedreading_ = loggedreading;
  if (loggedreading) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.DataRecord.loggedReading)
}

// .fk_data.Metadata metadata = 2;
inline bool DataRecord::has_metadata() const {
  return this != internal_default_instance() && metadata_ != NULL;
}
inline void DataRecord::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) delete metadata_;
  metadata_ = NULL;
}
inline const ::fk_data::Metadata& DataRecord::metadata() const {
  const ::fk_data::Metadata* p = metadata_;
  // @@protoc_insertion_point(field_get:fk_data.DataRecord.metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::Metadata*>(
      &::fk_data::_Metadata_default_instance_);
}
inline ::fk_data::Metadata* DataRecord::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::fk_data::Metadata;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.DataRecord.metadata)
  return metadata_;
}
inline ::fk_data::Metadata* DataRecord::release_metadata() {
  // @@protoc_insertion_point(field_release:fk_data.DataRecord.metadata)
  
  ::fk_data::Metadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_metadata(::fk_data::Metadata* metadata) {
  delete metadata_;
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.DataRecord.metadata)
}

// .fk_data.LogMessage log = 3;
inline bool DataRecord::has_log() const {
  return this != internal_default_instance() && log_ != NULL;
}
inline void DataRecord::clear_log() {
  if (GetArenaNoVirtual() == NULL && log_ != NULL) delete log_;
  log_ = NULL;
}
inline const ::fk_data::LogMessage& DataRecord::log() const {
  const ::fk_data::LogMessage* p = log_;
  // @@protoc_insertion_point(field_get:fk_data.DataRecord.log)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::LogMessage*>(
      &::fk_data::_LogMessage_default_instance_);
}
inline ::fk_data::LogMessage* DataRecord::mutable_log() {
  
  if (log_ == NULL) {
    log_ = new ::fk_data::LogMessage;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.DataRecord.log)
  return log_;
}
inline ::fk_data::LogMessage* DataRecord::release_log() {
  // @@protoc_insertion_point(field_release:fk_data.DataRecord.log)
  
  ::fk_data::LogMessage* temp = log_;
  log_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_log(::fk_data::LogMessage* log) {
  delete log_;
  log_ = log;
  if (log) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.DataRecord.log)
}

// .fk_data.Status status = 4;
inline bool DataRecord::has_status() const {
  return this != internal_default_instance() && status_ != NULL;
}
inline void DataRecord::clear_status() {
  if (GetArenaNoVirtual() == NULL && status_ != NULL) delete status_;
  status_ = NULL;
}
inline const ::fk_data::Status& DataRecord::status() const {
  const ::fk_data::Status* p = status_;
  // @@protoc_insertion_point(field_get:fk_data.DataRecord.status)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::Status*>(
      &::fk_data::_Status_default_instance_);
}
inline ::fk_data::Status* DataRecord::mutable_status() {
  
  if (status_ == NULL) {
    status_ = new ::fk_data::Status;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.DataRecord.status)
  return status_;
}
inline ::fk_data::Status* DataRecord::release_status() {
  // @@protoc_insertion_point(field_release:fk_data.DataRecord.status)
  
  ::fk_data::Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_status(::fk_data::Status* status) {
  delete status_;
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.DataRecord.status)
}

// .fk_data.Readings readings = 5;
inline bool DataRecord::has_readings() const {
  return this != internal_default_instance() && readings_ != NULL;
}
inline void DataRecord::clear_readings() {
  if (GetArenaNoVirtual() == NULL && readings_ != NULL) delete readings_;
  readings_ = NULL;
}
inline const ::fk_data::Readings& DataRecord::readings() const {
  const ::fk_data::Readings* p = readings_;
  // @@protoc_insertion_point(field_get:fk_data.DataRecord.readings)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::Readings*>(
      &::fk_data::_Readings_default_instance_);
}
inline ::fk_data::Readings* DataRecord::mutable_readings() {
  
  if (readings_ == NULL) {
    readings_ = new ::fk_data::Readings;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.DataRecord.readings)
  return readings_;
}
inline ::fk_data::Readings* DataRecord::release_readings() {
  // @@protoc_insertion_point(field_release:fk_data.DataRecord.readings)
  
  ::fk_data::Readings* temp = readings_;
  readings_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_readings(::fk_data::Readings* readings) {
  delete readings_;
  readings_ = readings;
  if (readings) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.DataRecord.readings)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace fk_data

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::fk_data::DownloadFlags> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fk_data::DownloadFlags>() {
  return ::fk_data::DownloadFlags_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_fk_2ddata_2eproto__INCLUDED
