// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fk-data.proto

#ifndef PROTOBUF_fk_2ddata_2eproto__INCLUDED
#define PROTOBUF_fk_2ddata_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace fk_data {
class Condition;
class ConditionDefaultTypeInternal;
extern ConditionDefaultTypeInternal _Condition_default_instance_;
class DataRecord;
class DataRecordDefaultTypeInternal;
extern DataRecordDefaultTypeInternal _DataRecord_default_instance_;
class DeviceLocation;
class DeviceLocationDefaultTypeInternal;
extern DeviceLocationDefaultTypeInternal _DeviceLocation_default_instance_;
class Firmware;
class FirmwareDefaultTypeInternal;
extern FirmwareDefaultTypeInternal _Firmware_default_instance_;
class Identity;
class IdentityDefaultTypeInternal;
extern IdentityDefaultTypeInternal _Identity_default_instance_;
class JobSchedule;
class JobScheduleDefaultTypeInternal;
extern JobScheduleDefaultTypeInternal _JobSchedule_default_instance_;
class LogMessage;
class LogMessageDefaultTypeInternal;
extern LogMessageDefaultTypeInternal _LogMessage_default_instance_;
class LoggedReading;
class LoggedReadingDefaultTypeInternal;
extern LoggedReadingDefaultTypeInternal _LoggedReading_default_instance_;
class LoraRecord;
class LoraRecordDefaultTypeInternal;
extern LoraRecordDefaultTypeInternal _LoraRecord_default_instance_;
class LoraSettings;
class LoraSettingsDefaultTypeInternal;
extern LoraSettingsDefaultTypeInternal _LoraSettings_default_instance_;
class Metadata;
class MetadataDefaultTypeInternal;
extern MetadataDefaultTypeInternal _Metadata_default_instance_;
class ModuleHeader;
class ModuleHeaderDefaultTypeInternal;
extern ModuleHeaderDefaultTypeInternal _ModuleHeader_default_instance_;
class ModuleInfo;
class ModuleInfoDefaultTypeInternal;
extern ModuleInfoDefaultTypeInternal _ModuleInfo_default_instance_;
class NetworkInfo;
class NetworkInfoDefaultTypeInternal;
extern NetworkInfoDefaultTypeInternal _NetworkInfo_default_instance_;
class NetworkSettings;
class NetworkSettingsDefaultTypeInternal;
extern NetworkSettingsDefaultTypeInternal _NetworkSettings_default_instance_;
class Readings;
class ReadingsDefaultTypeInternal;
extern ReadingsDefaultTypeInternal _Readings_default_instance_;
class Schedule;
class ScheduleDefaultTypeInternal;
extern ScheduleDefaultTypeInternal _Schedule_default_instance_;
class SensorAndValue;
class SensorAndValueDefaultTypeInternal;
extern SensorAndValueDefaultTypeInternal _SensorAndValue_default_instance_;
class SensorGroup;
class SensorGroupDefaultTypeInternal;
extern SensorGroupDefaultTypeInternal _SensorGroup_default_instance_;
class SensorInfo;
class SensorInfoDefaultTypeInternal;
extern SensorInfoDefaultTypeInternal _SensorInfo_default_instance_;
class SensorReading;
class SensorReadingDefaultTypeInternal;
extern SensorReadingDefaultTypeInternal _SensorReading_default_instance_;
class SignedRecord;
class SignedRecordDefaultTypeInternal;
extern SignedRecordDefaultTypeInternal _SignedRecord_default_instance_;
class Status;
class StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
}  // namespace fk_data

namespace fk_data {

namespace protobuf_fk_2ddata_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_fk_2ddata_2eproto

enum DownloadFlags {
  READING_FLAGS_NONE = 0,
  READING_FLAGS_NOT_RECORDING = 1,
  READING_FLAGS_MANUAL = 2,
  DownloadFlags_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DownloadFlags_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DownloadFlags_IsValid(int value);
const DownloadFlags DownloadFlags_MIN = READING_FLAGS_NONE;
const DownloadFlags DownloadFlags_MAX = READING_FLAGS_MANUAL;
const int DownloadFlags_ARRAYSIZE = DownloadFlags_MAX + 1;

const ::google::protobuf::EnumDescriptor* DownloadFlags_descriptor();
inline const ::std::string& DownloadFlags_Name(DownloadFlags value) {
  return ::google::protobuf::internal::NameOfEnum(
    DownloadFlags_descriptor(), value);
}
inline bool DownloadFlags_Parse(
    const ::std::string& name, DownloadFlags* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DownloadFlags>(
    DownloadFlags_descriptor(), name, value);
}
enum ConditionFlags {
  CONDITION_FLAGS_NONE = 0,
  CONDITION_FLAGS_RECORDING = 1,
  ConditionFlags_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ConditionFlags_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ConditionFlags_IsValid(int value);
const ConditionFlags ConditionFlags_MIN = CONDITION_FLAGS_NONE;
const ConditionFlags ConditionFlags_MAX = CONDITION_FLAGS_RECORDING;
const int ConditionFlags_ARRAYSIZE = ConditionFlags_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConditionFlags_descriptor();
inline const ::std::string& ConditionFlags_Name(ConditionFlags value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConditionFlags_descriptor(), value);
}
inline bool ConditionFlags_Parse(
    const ::std::string& name, ConditionFlags* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConditionFlags>(
    ConditionFlags_descriptor(), name, value);
}
enum SignedRecordKind {
  SIGNED_RECORD_KIND_NONE = 0,
  SIGNED_RECORD_KIND_MODULES = 1,
  SIGNED_RECORD_KIND_SCHEDULE = 2,
  SIGNED_RECORD_KIND_STATE = 3,
  SIGNED_RECORD_KIND_RAW_STATE = 4,
  SIGNED_RECORD_KIND_OTHER = 255,
  SignedRecordKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SignedRecordKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SignedRecordKind_IsValid(int value);
const SignedRecordKind SignedRecordKind_MIN = SIGNED_RECORD_KIND_NONE;
const SignedRecordKind SignedRecordKind_MAX = SIGNED_RECORD_KIND_OTHER;
const int SignedRecordKind_ARRAYSIZE = SignedRecordKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* SignedRecordKind_descriptor();
inline const ::std::string& SignedRecordKind_Name(SignedRecordKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    SignedRecordKind_descriptor(), value);
}
inline bool SignedRecordKind_Parse(
    const ::std::string& name, SignedRecordKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SignedRecordKind>(
    SignedRecordKind_descriptor(), name, value);
}
// ===================================================================

class DeviceLocation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.DeviceLocation) */ {
 public:
  DeviceLocation();
  virtual ~DeviceLocation();

  DeviceLocation(const DeviceLocation& from);

  inline DeviceLocation& operator=(const DeviceLocation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeviceLocation(DeviceLocation&& from) noexcept
    : DeviceLocation() {
    *this = ::std::move(from);
  }

  inline DeviceLocation& operator=(DeviceLocation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceLocation& default_instance();

  static inline const DeviceLocation* internal_default_instance() {
    return reinterpret_cast<const DeviceLocation*>(
               &_DeviceLocation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(DeviceLocation* other);
  friend void swap(DeviceLocation& a, DeviceLocation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeviceLocation* New() const PROTOBUF_FINAL { return New(NULL); }

  DeviceLocation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeviceLocation& from);
  void MergeFrom(const DeviceLocation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeviceLocation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float coordinates = 6;
  int coordinates_size() const;
  void clear_coordinates();
  static const int kCoordinatesFieldNumber = 6;
  float coordinates(int index) const;
  void set_coordinates(int index, float value);
  void add_coordinates(float value);
  const ::google::protobuf::RepeatedField< float >&
      coordinates() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_coordinates();

  // uint64 time = 2;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // uint32 fix = 1;
  void clear_fix();
  static const int kFixFieldNumber = 1;
  ::google::protobuf::uint32 fix() const;
  void set_fix(::google::protobuf::uint32 value);

  // float longitude = 3;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 3;
  float longitude() const;
  void set_longitude(float value);

  // float latitude = 4;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 4;
  float latitude() const;
  void set_latitude(float value);

  // float altitude = 5;
  void clear_altitude();
  static const int kAltitudeFieldNumber = 5;
  float altitude() const;
  void set_altitude(float value);

  // uint32 enabled = 7;
  void clear_enabled();
  static const int kEnabledFieldNumber = 7;
  ::google::protobuf::uint32 enabled() const;
  void set_enabled(::google::protobuf::uint32 value);

  // uint32 satellites = 8;
  void clear_satellites();
  static const int kSatellitesFieldNumber = 8;
  ::google::protobuf::uint32 satellites() const;
  void set_satellites(::google::protobuf::uint32 value);

  // uint32 hdop = 9;
  void clear_hdop();
  static const int kHdopFieldNumber = 9;
  ::google::protobuf::uint32 hdop() const;
  void set_hdop(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fk_data.DeviceLocation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > coordinates_;
  mutable int _coordinates_cached_byte_size_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint32 fix_;
  float longitude_;
  float latitude_;
  float altitude_;
  ::google::protobuf::uint32 enabled_;
  ::google::protobuf::uint32 satellites_;
  ::google::protobuf::uint32 hdop_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SensorReading : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.SensorReading) */ {
 public:
  SensorReading();
  virtual ~SensorReading();

  SensorReading(const SensorReading& from);

  inline SensorReading& operator=(const SensorReading& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorReading(SensorReading&& from) noexcept
    : SensorReading() {
    *this = ::std::move(from);
  }

  inline SensorReading& operator=(SensorReading&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorReading& default_instance();

  static inline const SensorReading* internal_default_instance() {
    return reinterpret_cast<const SensorReading*>(
               &_SensorReading_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(SensorReading* other);
  friend void swap(SensorReading& a, SensorReading& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorReading* New() const PROTOBUF_FINAL { return New(NULL); }

  SensorReading* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SensorReading& from);
  void MergeFrom(const SensorReading& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SensorReading* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 time = 2;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // uint32 reading = 1;
  void clear_reading();
  static const int kReadingFieldNumber = 1;
  ::google::protobuf::uint32 reading() const;
  void set_reading(::google::protobuf::uint32 value);

  // uint32 sensor = 3;
  void clear_sensor();
  static const int kSensorFieldNumber = 3;
  ::google::protobuf::uint32 sensor() const;
  void set_sensor(::google::protobuf::uint32 value);

  // float value = 4;
  void clear_value();
  static const int kValueFieldNumber = 4;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:fk_data.SensorReading)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint32 reading_;
  ::google::protobuf::uint32 sensor_;
  float value_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoggedReading : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.LoggedReading) */ {
 public:
  LoggedReading();
  virtual ~LoggedReading();

  LoggedReading(const LoggedReading& from);

  inline LoggedReading& operator=(const LoggedReading& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoggedReading(LoggedReading&& from) noexcept
    : LoggedReading() {
    *this = ::std::move(from);
  }

  inline LoggedReading& operator=(LoggedReading&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoggedReading& default_instance();

  static inline const LoggedReading* internal_default_instance() {
    return reinterpret_cast<const LoggedReading*>(
               &_LoggedReading_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(LoggedReading* other);
  friend void swap(LoggedReading& a, LoggedReading& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoggedReading* New() const PROTOBUF_FINAL { return New(NULL); }

  LoggedReading* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoggedReading& from);
  void MergeFrom(const LoggedReading& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoggedReading* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .fk_data.DeviceLocation location = 2;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 2;
  const ::fk_data::DeviceLocation& location() const;
  ::fk_data::DeviceLocation* mutable_location();
  ::fk_data::DeviceLocation* release_location();
  void set_allocated_location(::fk_data::DeviceLocation* location);

  // .fk_data.SensorReading reading = 3;
  bool has_reading() const;
  void clear_reading();
  static const int kReadingFieldNumber = 3;
  const ::fk_data::SensorReading& reading() const;
  ::fk_data::SensorReading* mutable_reading();
  ::fk_data::SensorReading* release_reading();
  void set_allocated_reading(::fk_data::SensorReading* reading);

  // uint32 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fk_data.LoggedReading)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::fk_data::DeviceLocation* location_;
  ::fk_data::SensorReading* reading_;
  ::google::protobuf::uint32 version_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SensorAndValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.SensorAndValue) */ {
 public:
  SensorAndValue();
  virtual ~SensorAndValue();

  SensorAndValue(const SensorAndValue& from);

  inline SensorAndValue& operator=(const SensorAndValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorAndValue(SensorAndValue&& from) noexcept
    : SensorAndValue() {
    *this = ::std::move(from);
  }

  inline SensorAndValue& operator=(SensorAndValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorAndValue& default_instance();

  static inline const SensorAndValue* internal_default_instance() {
    return reinterpret_cast<const SensorAndValue*>(
               &_SensorAndValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(SensorAndValue* other);
  friend void swap(SensorAndValue& a, SensorAndValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorAndValue* New() const PROTOBUF_FINAL { return New(NULL); }

  SensorAndValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SensorAndValue& from);
  void MergeFrom(const SensorAndValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SensorAndValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 sensor = 1;
  void clear_sensor();
  static const int kSensorFieldNumber = 1;
  ::google::protobuf::uint32 sensor() const;
  void set_sensor(::google::protobuf::uint32 value);

  // float value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:fk_data.SensorAndValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 sensor_;
  float value_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModuleHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.ModuleHeader) */ {
 public:
  ModuleHeader();
  virtual ~ModuleHeader();

  ModuleHeader(const ModuleHeader& from);

  inline ModuleHeader& operator=(const ModuleHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModuleHeader(ModuleHeader&& from) noexcept
    : ModuleHeader() {
    *this = ::std::move(from);
  }

  inline ModuleHeader& operator=(ModuleHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleHeader& default_instance();

  static inline const ModuleHeader* internal_default_instance() {
    return reinterpret_cast<const ModuleHeader*>(
               &_ModuleHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ModuleHeader* other);
  friend void swap(ModuleHeader& a, ModuleHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModuleHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  ModuleHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ModuleHeader& from);
  void MergeFrom(const ModuleHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ModuleHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 manufacturer = 1;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 1;
  ::google::protobuf::uint32 manufacturer() const;
  void set_manufacturer(::google::protobuf::uint32 value);

  // uint32 kind = 2;
  void clear_kind();
  static const int kKindFieldNumber = 2;
  ::google::protobuf::uint32 kind() const;
  void set_kind(::google::protobuf::uint32 value);

  // uint32 version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fk_data.ModuleHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 manufacturer_;
  ::google::protobuf::uint32 kind_;
  ::google::protobuf::uint32 version_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModuleInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.ModuleInfo) */ {
 public:
  ModuleInfo();
  virtual ~ModuleInfo();

  ModuleInfo(const ModuleInfo& from);

  inline ModuleInfo& operator=(const ModuleInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModuleInfo(ModuleInfo&& from) noexcept
    : ModuleInfo() {
    *this = ::std::move(from);
  }

  inline ModuleInfo& operator=(ModuleInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleInfo& default_instance();

  static inline const ModuleInfo* internal_default_instance() {
    return reinterpret_cast<const ModuleInfo*>(
               &_ModuleInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ModuleInfo* other);
  friend void swap(ModuleInfo& a, ModuleInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModuleInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ModuleInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ModuleInfo& from);
  void MergeFrom(const ModuleInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ModuleInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fk_data.SensorInfo sensors = 6;
  int sensors_size() const;
  void clear_sensors();
  static const int kSensorsFieldNumber = 6;
  const ::fk_data::SensorInfo& sensors(int index) const;
  ::fk_data::SensorInfo* mutable_sensors(int index);
  ::fk_data::SensorInfo* add_sensors();
  ::google::protobuf::RepeatedPtrField< ::fk_data::SensorInfo >*
      mutable_sensors();
  const ::google::protobuf::RepeatedPtrField< ::fk_data::SensorInfo >&
      sensors() const;

  // string name = 3;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bytes id = 7;
  void clear_id();
  static const int kIdFieldNumber = 7;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // .fk_data.ModuleHeader header = 4;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 4;
  const ::fk_data::ModuleHeader& header() const;
  ::fk_data::ModuleHeader* mutable_header();
  ::fk_data::ModuleHeader* release_header();
  void set_allocated_header(::fk_data::ModuleHeader* header);

  // .fk_data.Firmware firmware = 5;
  bool has_firmware() const;
  void clear_firmware();
  static const int kFirmwareFieldNumber = 5;
  const ::fk_data::Firmware& firmware() const;
  ::fk_data::Firmware* mutable_firmware();
  ::fk_data::Firmware* release_firmware();
  void set_allocated_firmware(::fk_data::Firmware* firmware);

  // uint32 position = 1;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  ::google::protobuf::uint32 position() const;
  void set_position(::google::protobuf::uint32 value);

  // uint32 address = 2;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  ::google::protobuf::uint32 address() const;
  void set_address(::google::protobuf::uint32 value);

  // uint32 flags = 8;
  void clear_flags();
  static const int kFlagsFieldNumber = 8;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fk_data.ModuleInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::fk_data::SensorInfo > sensors_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::fk_data::ModuleHeader* header_;
  ::fk_data::Firmware* firmware_;
  ::google::protobuf::uint32 position_;
  ::google::protobuf::uint32 address_;
  ::google::protobuf::uint32 flags_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SensorInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.SensorInfo) */ {
 public:
  SensorInfo();
  virtual ~SensorInfo();

  SensorInfo(const SensorInfo& from);

  inline SensorInfo& operator=(const SensorInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorInfo(SensorInfo&& from) noexcept
    : SensorInfo() {
    *this = ::std::move(from);
  }

  inline SensorInfo& operator=(SensorInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorInfo& default_instance();

  static inline const SensorInfo* internal_default_instance() {
    return reinterpret_cast<const SensorInfo*>(
               &_SensorInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(SensorInfo* other);
  friend void swap(SensorInfo& a, SensorInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  SensorInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SensorInfo& from);
  void MergeFrom(const SensorInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SensorInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string unitOfMeasure = 3;
  void clear_unitofmeasure();
  static const int kUnitOfMeasureFieldNumber = 3;
  const ::std::string& unitofmeasure() const;
  void set_unitofmeasure(const ::std::string& value);
  #if LANG_CXX11
  void set_unitofmeasure(::std::string&& value);
  #endif
  void set_unitofmeasure(const char* value);
  void set_unitofmeasure(const char* value, size_t size);
  ::std::string* mutable_unitofmeasure();
  ::std::string* release_unitofmeasure();
  void set_allocated_unitofmeasure(::std::string* unitofmeasure);

  // uint32 number = 1;
  void clear_number();
  static const int kNumberFieldNumber = 1;
  ::google::protobuf::uint32 number() const;
  void set_number(::google::protobuf::uint32 value);

  // uint32 flags = 4;
  void clear_flags();
  static const int kFlagsFieldNumber = 4;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fk_data.SensorInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr unitofmeasure_;
  ::google::protobuf::uint32 number_;
  ::google::protobuf::uint32 flags_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Firmware : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.Firmware) */ {
 public:
  Firmware();
  virtual ~Firmware();

  Firmware(const Firmware& from);

  inline Firmware& operator=(const Firmware& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Firmware(Firmware&& from) noexcept
    : Firmware() {
    *this = ::std::move(from);
  }

  inline Firmware& operator=(Firmware&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Firmware& default_instance();

  static inline const Firmware* internal_default_instance() {
    return reinterpret_cast<const Firmware*>(
               &_Firmware_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Firmware* other);
  friend void swap(Firmware& a, Firmware& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Firmware* New() const PROTOBUF_FINAL { return New(NULL); }

  Firmware* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Firmware& from);
  void MergeFrom(const Firmware& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Firmware* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string git = 1;
  void clear_git();
  static const int kGitFieldNumber = 1;
  const ::std::string& git() const;
  void set_git(const ::std::string& value);
  #if LANG_CXX11
  void set_git(::std::string&& value);
  #endif
  void set_git(const char* value);
  void set_git(const char* value, size_t size);
  ::std::string* mutable_git();
  ::std::string* release_git();
  void set_allocated_git(::std::string* git);

  // string build = 2;
  void clear_build();
  static const int kBuildFieldNumber = 2;
  const ::std::string& build() const;
  void set_build(const ::std::string& value);
  #if LANG_CXX11
  void set_build(::std::string&& value);
  #endif
  void set_build(const char* value);
  void set_build(const char* value, size_t size);
  ::std::string* mutable_build();
  ::std::string* release_build();
  void set_allocated_build(::std::string* build);

  // @@protoc_insertion_point(class_scope:fk_data.Firmware)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr git_;
  ::google::protobuf::internal::ArenaStringPtr build_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Metadata : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.Metadata) */ {
 public:
  Metadata();
  virtual ~Metadata();

  Metadata(const Metadata& from);

  inline Metadata& operator=(const Metadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Metadata(Metadata&& from) noexcept
    : Metadata() {
    *this = ::std::move(from);
  }

  inline Metadata& operator=(Metadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Metadata& default_instance();

  static inline const Metadata* internal_default_instance() {
    return reinterpret_cast<const Metadata*>(
               &_Metadata_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Metadata* other);
  friend void swap(Metadata& a, Metadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Metadata* New() const PROTOBUF_FINAL { return New(NULL); }

  Metadata* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Metadata& from);
  void MergeFrom(const Metadata& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Metadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fk_data.SensorInfo sensors = 5;
  int sensors_size() const;
  void clear_sensors();
  static const int kSensorsFieldNumber = 5;
  const ::fk_data::SensorInfo& sensors(int index) const;
  ::fk_data::SensorInfo* mutable_sensors(int index);
  ::fk_data::SensorInfo* add_sensors();
  ::google::protobuf::RepeatedPtrField< ::fk_data::SensorInfo >*
      mutable_sensors();
  const ::google::protobuf::RepeatedPtrField< ::fk_data::SensorInfo >&
      sensors() const;

  // repeated .fk_data.ModuleInfo modules = 6;
  int modules_size() const;
  void clear_modules();
  static const int kModulesFieldNumber = 6;
  const ::fk_data::ModuleInfo& modules(int index) const;
  ::fk_data::ModuleInfo* mutable_modules(int index);
  ::fk_data::ModuleInfo* add_modules();
  ::google::protobuf::RepeatedPtrField< ::fk_data::ModuleInfo >*
      mutable_modules();
  const ::google::protobuf::RepeatedPtrField< ::fk_data::ModuleInfo >&
      modules() const;

  // bytes deviceId = 1;
  void clear_deviceid();
  static const int kDeviceIdFieldNumber = 1;
  const ::std::string& deviceid() const;
  void set_deviceid(const ::std::string& value);
  #if LANG_CXX11
  void set_deviceid(::std::string&& value);
  #endif
  void set_deviceid(const char* value);
  void set_deviceid(const void* value, size_t size);
  ::std::string* mutable_deviceid();
  ::std::string* release_deviceid();
  void set_allocated_deviceid(::std::string* deviceid);

  // string git = 3;
  void clear_git();
  static const int kGitFieldNumber = 3;
  const ::std::string& git() const;
  void set_git(const ::std::string& value);
  #if LANG_CXX11
  void set_git(::std::string&& value);
  #endif
  void set_git(const char* value);
  void set_git(const char* value, size_t size);
  ::std::string* mutable_git();
  ::std::string* release_git();
  void set_allocated_git(::std::string* git);

  // string build = 7;
  void clear_build();
  static const int kBuildFieldNumber = 7;
  const ::std::string& build() const;
  void set_build(const ::std::string& value);
  #if LANG_CXX11
  void set_build(::std::string&& value);
  #endif
  void set_build(const char* value);
  void set_build(const char* value, size_t size);
  ::std::string* mutable_build();
  ::std::string* release_build();
  void set_allocated_build(::std::string* build);

  // bytes generation = 9;
  void clear_generation();
  static const int kGenerationFieldNumber = 9;
  const ::std::string& generation() const;
  void set_generation(const ::std::string& value);
  #if LANG_CXX11
  void set_generation(::std::string&& value);
  #endif
  void set_generation(const char* value);
  void set_generation(const void* value, size_t size);
  ::std::string* mutable_generation();
  ::std::string* release_generation();
  void set_allocated_generation(::std::string* generation);

  // .fk_data.Firmware firmware = 8;
  bool has_firmware() const;
  void clear_firmware();
  static const int kFirmwareFieldNumber = 8;
  const ::fk_data::Firmware& firmware() const;
  ::fk_data::Firmware* mutable_firmware();
  ::fk_data::Firmware* release_firmware();
  void set_allocated_firmware(::fk_data::Firmware* firmware);

  // uint64 time = 2;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // uint32 resetCause = 4;
  void clear_resetcause();
  static const int kResetCauseFieldNumber = 4;
  ::google::protobuf::uint32 resetcause() const;
  void set_resetcause(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fk_data.Metadata)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::fk_data::SensorInfo > sensors_;
  ::google::protobuf::RepeatedPtrField< ::fk_data::ModuleInfo > modules_;
  ::google::protobuf::internal::ArenaStringPtr deviceid_;
  ::google::protobuf::internal::ArenaStringPtr git_;
  ::google::protobuf::internal::ArenaStringPtr build_;
  ::google::protobuf::internal::ArenaStringPtr generation_;
  ::fk_data::Firmware* firmware_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint32 resetcause_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Status : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.Status) */ {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(Status&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();

  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Status* other);
  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Status* New() const PROTOBUF_FINAL { return New(NULL); }

  Status* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Status* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // uint32 uptime = 2;
  void clear_uptime();
  static const int kUptimeFieldNumber = 2;
  ::google::protobuf::uint32 uptime() const;
  void set_uptime(::google::protobuf::uint32 value);

  // float battery = 3;
  void clear_battery();
  static const int kBatteryFieldNumber = 3;
  float battery() const;
  void set_battery(float value);

  // uint64 busy = 5;
  void clear_busy();
  static const int kBusyFieldNumber = 5;
  ::google::protobuf::uint64 busy() const;
  void set_busy(::google::protobuf::uint64 value);

  // uint32 memory = 4;
  void clear_memory();
  static const int kMemoryFieldNumber = 4;
  ::google::protobuf::uint32 memory() const;
  void set_memory(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fk_data.Status)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint32 uptime_;
  float battery_;
  ::google::protobuf::uint64 busy_;
  ::google::protobuf::uint32 memory_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.LogMessage) */ {
 public:
  LogMessage();
  virtual ~LogMessage();

  LogMessage(const LogMessage& from);

  inline LogMessage& operator=(const LogMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogMessage(LogMessage&& from) noexcept
    : LogMessage() {
    *this = ::std::move(from);
  }

  inline LogMessage& operator=(LogMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogMessage& default_instance();

  static inline const LogMessage* internal_default_instance() {
    return reinterpret_cast<const LogMessage*>(
               &_LogMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(LogMessage* other);
  friend void swap(LogMessage& a, LogMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  LogMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LogMessage& from);
  void MergeFrom(const LogMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LogMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string facility = 4;
  void clear_facility();
  static const int kFacilityFieldNumber = 4;
  const ::std::string& facility() const;
  void set_facility(const ::std::string& value);
  #if LANG_CXX11
  void set_facility(::std::string&& value);
  #endif
  void set_facility(const char* value);
  void set_facility(const char* value, size_t size);
  ::std::string* mutable_facility();
  ::std::string* release_facility();
  void set_allocated_facility(::std::string* facility);

  // string message = 5;
  void clear_message();
  static const int kMessageFieldNumber = 5;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // uint64 time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // uint32 uptime = 2;
  void clear_uptime();
  static const int kUptimeFieldNumber = 2;
  ::google::protobuf::uint32 uptime() const;
  void set_uptime(::google::protobuf::uint32 value);

  // uint32 level = 3;
  void clear_level();
  static const int kLevelFieldNumber = 3;
  ::google::protobuf::uint32 level() const;
  void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fk_data.LogMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr facility_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint32 uptime_;
  ::google::protobuf::uint32 level_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SensorGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.SensorGroup) */ {
 public:
  SensorGroup();
  virtual ~SensorGroup();

  SensorGroup(const SensorGroup& from);

  inline SensorGroup& operator=(const SensorGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorGroup(SensorGroup&& from) noexcept
    : SensorGroup() {
    *this = ::std::move(from);
  }

  inline SensorGroup& operator=(SensorGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorGroup& default_instance();

  static inline const SensorGroup* internal_default_instance() {
    return reinterpret_cast<const SensorGroup*>(
               &_SensorGroup_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(SensorGroup* other);
  friend void swap(SensorGroup& a, SensorGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorGroup* New() const PROTOBUF_FINAL { return New(NULL); }

  SensorGroup* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SensorGroup& from);
  void MergeFrom(const SensorGroup& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SensorGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fk_data.SensorAndValue readings = 2;
  int readings_size() const;
  void clear_readings();
  static const int kReadingsFieldNumber = 2;
  const ::fk_data::SensorAndValue& readings(int index) const;
  ::fk_data::SensorAndValue* mutable_readings(int index);
  ::fk_data::SensorAndValue* add_readings();
  ::google::protobuf::RepeatedPtrField< ::fk_data::SensorAndValue >*
      mutable_readings();
  const ::google::protobuf::RepeatedPtrField< ::fk_data::SensorAndValue >&
      readings() const;

  // uint32 module = 1;
  void clear_module();
  static const int kModuleFieldNumber = 1;
  ::google::protobuf::uint32 module() const;
  void set_module(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fk_data.SensorGroup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::fk_data::SensorAndValue > readings_;
  ::google::protobuf::uint32 module_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Readings : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.Readings) */ {
 public:
  Readings();
  virtual ~Readings();

  Readings(const Readings& from);

  inline Readings& operator=(const Readings& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Readings(Readings&& from) noexcept
    : Readings() {
    *this = ::std::move(from);
  }

  inline Readings& operator=(Readings&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Readings& default_instance();

  static inline const Readings* internal_default_instance() {
    return reinterpret_cast<const Readings*>(
               &_Readings_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(Readings* other);
  friend void swap(Readings& a, Readings& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Readings* New() const PROTOBUF_FINAL { return New(NULL); }

  Readings* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Readings& from);
  void MergeFrom(const Readings& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Readings* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fk_data.SensorGroup sensorGroups = 5;
  int sensorgroups_size() const;
  void clear_sensorgroups();
  static const int kSensorGroupsFieldNumber = 5;
  const ::fk_data::SensorGroup& sensorgroups(int index) const;
  ::fk_data::SensorGroup* mutable_sensorgroups(int index);
  ::fk_data::SensorGroup* add_sensorgroups();
  ::google::protobuf::RepeatedPtrField< ::fk_data::SensorGroup >*
      mutable_sensorgroups();
  const ::google::protobuf::RepeatedPtrField< ::fk_data::SensorGroup >&
      sensorgroups() const;

  // .fk_data.DeviceLocation location = 4;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 4;
  const ::fk_data::DeviceLocation& location() const;
  ::fk_data::DeviceLocation* mutable_location();
  ::fk_data::DeviceLocation* release_location();
  void set_allocated_location(::fk_data::DeviceLocation* location);

  // uint64 time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // uint32 reading = 2;
  void clear_reading();
  static const int kReadingFieldNumber = 2;
  ::google::protobuf::uint32 reading() const;
  void set_reading(::google::protobuf::uint32 value);

  // uint32 flags = 3;
  void clear_flags();
  static const int kFlagsFieldNumber = 3;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // uint32 meta = 6;
  void clear_meta();
  static const int kMetaFieldNumber = 6;
  ::google::protobuf::uint32 meta() const;
  void set_meta(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fk_data.Readings)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::fk_data::SensorGroup > sensorgroups_;
  ::fk_data::DeviceLocation* location_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint32 reading_;
  ::google::protobuf::uint32 flags_;
  ::google::protobuf::uint32 meta_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JobSchedule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.JobSchedule) */ {
 public:
  JobSchedule();
  virtual ~JobSchedule();

  JobSchedule(const JobSchedule& from);

  inline JobSchedule& operator=(const JobSchedule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JobSchedule(JobSchedule&& from) noexcept
    : JobSchedule() {
    *this = ::std::move(from);
  }

  inline JobSchedule& operator=(JobSchedule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JobSchedule& default_instance();

  static inline const JobSchedule* internal_default_instance() {
    return reinterpret_cast<const JobSchedule*>(
               &_JobSchedule_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(JobSchedule* other);
  friend void swap(JobSchedule& a, JobSchedule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JobSchedule* New() const PROTOBUF_FINAL { return New(NULL); }

  JobSchedule* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JobSchedule& from);
  void MergeFrom(const JobSchedule& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JobSchedule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes cron = 1;
  void clear_cron();
  static const int kCronFieldNumber = 1;
  const ::std::string& cron() const;
  void set_cron(const ::std::string& value);
  #if LANG_CXX11
  void set_cron(::std::string&& value);
  #endif
  void set_cron(const char* value);
  void set_cron(const void* value, size_t size);
  ::std::string* mutable_cron();
  ::std::string* release_cron();
  void set_allocated_cron(::std::string* cron);

  // uint32 interval = 2;
  void clear_interval();
  static const int kIntervalFieldNumber = 2;
  ::google::protobuf::uint32 interval() const;
  void set_interval(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fk_data.JobSchedule)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr cron_;
  ::google::protobuf::uint32 interval_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Schedule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.Schedule) */ {
 public:
  Schedule();
  virtual ~Schedule();

  Schedule(const Schedule& from);

  inline Schedule& operator=(const Schedule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Schedule(Schedule&& from) noexcept
    : Schedule() {
    *this = ::std::move(from);
  }

  inline Schedule& operator=(Schedule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Schedule& default_instance();

  static inline const Schedule* internal_default_instance() {
    return reinterpret_cast<const Schedule*>(
               &_Schedule_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(Schedule* other);
  friend void swap(Schedule& a, Schedule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Schedule* New() const PROTOBUF_FINAL { return New(NULL); }

  Schedule* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Schedule& from);
  void MergeFrom(const Schedule& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Schedule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .fk_data.JobSchedule readings = 1;
  bool has_readings() const;
  void clear_readings();
  static const int kReadingsFieldNumber = 1;
  const ::fk_data::JobSchedule& readings() const;
  ::fk_data::JobSchedule* mutable_readings();
  ::fk_data::JobSchedule* release_readings();
  void set_allocated_readings(::fk_data::JobSchedule* readings);

  // .fk_data.JobSchedule network = 2;
  bool has_network() const;
  void clear_network();
  static const int kNetworkFieldNumber = 2;
  const ::fk_data::JobSchedule& network() const;
  ::fk_data::JobSchedule* mutable_network();
  ::fk_data::JobSchedule* release_network();
  void set_allocated_network(::fk_data::JobSchedule* network);

  // .fk_data.JobSchedule lora = 3;
  bool has_lora() const;
  void clear_lora();
  static const int kLoraFieldNumber = 3;
  const ::fk_data::JobSchedule& lora() const;
  ::fk_data::JobSchedule* mutable_lora();
  ::fk_data::JobSchedule* release_lora();
  void set_allocated_lora(::fk_data::JobSchedule* lora);

  // .fk_data.JobSchedule gps = 4;
  bool has_gps() const;
  void clear_gps();
  static const int kGpsFieldNumber = 4;
  const ::fk_data::JobSchedule& gps() const;
  ::fk_data::JobSchedule* mutable_gps();
  ::fk_data::JobSchedule* release_gps();
  void set_allocated_gps(::fk_data::JobSchedule* gps);

  // @@protoc_insertion_point(class_scope:fk_data.Schedule)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::fk_data::JobSchedule* readings_;
  ::fk_data::JobSchedule* network_;
  ::fk_data::JobSchedule* lora_;
  ::fk_data::JobSchedule* gps_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Identity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.Identity) */ {
 public:
  Identity();
  virtual ~Identity();

  Identity(const Identity& from);

  inline Identity& operator=(const Identity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Identity(Identity&& from) noexcept
    : Identity() {
    *this = ::std::move(from);
  }

  inline Identity& operator=(Identity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Identity& default_instance();

  static inline const Identity* internal_default_instance() {
    return reinterpret_cast<const Identity*>(
               &_Identity_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(Identity* other);
  friend void swap(Identity& a, Identity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Identity* New() const PROTOBUF_FINAL { return New(NULL); }

  Identity* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Identity& from);
  void MergeFrom(const Identity& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Identity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:fk_data.Identity)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Condition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.Condition) */ {
 public:
  Condition();
  virtual ~Condition();

  Condition(const Condition& from);

  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Condition(Condition&& from) noexcept
    : Condition() {
    *this = ::std::move(from);
  }

  inline Condition& operator=(Condition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Condition& default_instance();

  static inline const Condition* internal_default_instance() {
    return reinterpret_cast<const Condition*>(
               &_Condition_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(Condition* other);
  friend void swap(Condition& a, Condition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Condition* New() const PROTOBUF_FINAL { return New(NULL); }

  Condition* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Condition& from);
  void MergeFrom(const Condition& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Condition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 flags = 1;
  void clear_flags();
  static const int kFlagsFieldNumber = 1;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // uint32 recording = 2;
  void clear_recording();
  static const int kRecordingFieldNumber = 2;
  ::google::protobuf::uint32 recording() const;
  void set_recording(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fk_data.Condition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 flags_;
  ::google::protobuf::uint32 recording_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NetworkInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.NetworkInfo) */ {
 public:
  NetworkInfo();
  virtual ~NetworkInfo();

  NetworkInfo(const NetworkInfo& from);

  inline NetworkInfo& operator=(const NetworkInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkInfo(NetworkInfo&& from) noexcept
    : NetworkInfo() {
    *this = ::std::move(from);
  }

  inline NetworkInfo& operator=(NetworkInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkInfo& default_instance();

  static inline const NetworkInfo* internal_default_instance() {
    return reinterpret_cast<const NetworkInfo*>(
               &_NetworkInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(NetworkInfo* other);
  friend void swap(NetworkInfo& a, NetworkInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NetworkInfo& from);
  void MergeFrom(const NetworkInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NetworkInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ssid = 1;
  void clear_ssid();
  static const int kSsidFieldNumber = 1;
  const ::std::string& ssid() const;
  void set_ssid(const ::std::string& value);
  #if LANG_CXX11
  void set_ssid(::std::string&& value);
  #endif
  void set_ssid(const char* value);
  void set_ssid(const char* value, size_t size);
  ::std::string* mutable_ssid();
  ::std::string* release_ssid();
  void set_allocated_ssid(::std::string* ssid);

  // string password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:fk_data.NetworkInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ssid_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NetworkSettings : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.NetworkSettings) */ {
 public:
  NetworkSettings();
  virtual ~NetworkSettings();

  NetworkSettings(const NetworkSettings& from);

  inline NetworkSettings& operator=(const NetworkSettings& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkSettings(NetworkSettings&& from) noexcept
    : NetworkSettings() {
    *this = ::std::move(from);
  }

  inline NetworkSettings& operator=(NetworkSettings&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkSettings& default_instance();

  static inline const NetworkSettings* internal_default_instance() {
    return reinterpret_cast<const NetworkSettings*>(
               &_NetworkSettings_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(NetworkSettings* other);
  friend void swap(NetworkSettings& a, NetworkSettings& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkSettings* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkSettings* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NetworkSettings& from);
  void MergeFrom(const NetworkSettings& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NetworkSettings* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fk_data.NetworkInfo networks = 1;
  int networks_size() const;
  void clear_networks();
  static const int kNetworksFieldNumber = 1;
  const ::fk_data::NetworkInfo& networks(int index) const;
  ::fk_data::NetworkInfo* mutable_networks(int index);
  ::fk_data::NetworkInfo* add_networks();
  ::google::protobuf::RepeatedPtrField< ::fk_data::NetworkInfo >*
      mutable_networks();
  const ::google::protobuf::RepeatedPtrField< ::fk_data::NetworkInfo >&
      networks() const;

  // @@protoc_insertion_point(class_scope:fk_data.NetworkSettings)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::fk_data::NetworkInfo > networks_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoraSettings : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.LoraSettings) */ {
 public:
  LoraSettings();
  virtual ~LoraSettings();

  LoraSettings(const LoraSettings& from);

  inline LoraSettings& operator=(const LoraSettings& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoraSettings(LoraSettings&& from) noexcept
    : LoraSettings() {
    *this = ::std::move(from);
  }

  inline LoraSettings& operator=(LoraSettings&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoraSettings& default_instance();

  static inline const LoraSettings* internal_default_instance() {
    return reinterpret_cast<const LoraSettings*>(
               &_LoraSettings_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(LoraSettings* other);
  friend void swap(LoraSettings& a, LoraSettings& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoraSettings* New() const PROTOBUF_FINAL { return New(NULL); }

  LoraSettings* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoraSettings& from);
  void MergeFrom(const LoraSettings& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoraSettings* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes deviceEui = 1;
  void clear_deviceeui();
  static const int kDeviceEuiFieldNumber = 1;
  const ::std::string& deviceeui() const;
  void set_deviceeui(const ::std::string& value);
  #if LANG_CXX11
  void set_deviceeui(::std::string&& value);
  #endif
  void set_deviceeui(const char* value);
  void set_deviceeui(const void* value, size_t size);
  ::std::string* mutable_deviceeui();
  ::std::string* release_deviceeui();
  void set_allocated_deviceeui(::std::string* deviceeui);

  // bytes appKey = 2;
  void clear_appkey();
  static const int kAppKeyFieldNumber = 2;
  const ::std::string& appkey() const;
  void set_appkey(const ::std::string& value);
  #if LANG_CXX11
  void set_appkey(::std::string&& value);
  #endif
  void set_appkey(const char* value);
  void set_appkey(const void* value, size_t size);
  ::std::string* mutable_appkey();
  ::std::string* release_appkey();
  void set_allocated_appkey(::std::string* appkey);

  // bytes appEui = 3;
  void clear_appeui();
  static const int kAppEuiFieldNumber = 3;
  const ::std::string& appeui() const;
  void set_appeui(const ::std::string& value);
  #if LANG_CXX11
  void set_appeui(::std::string&& value);
  #endif
  void set_appeui(const char* value);
  void set_appeui(const void* value, size_t size);
  ::std::string* mutable_appeui();
  ::std::string* release_appeui();
  void set_allocated_appeui(::std::string* appeui);

  // uint32 frequencyBand = 4;
  void clear_frequencyband();
  static const int kFrequencyBandFieldNumber = 4;
  ::google::protobuf::uint32 frequencyband() const;
  void set_frequencyband(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fk_data.LoraSettings)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr deviceeui_;
  ::google::protobuf::internal::ArenaStringPtr appkey_;
  ::google::protobuf::internal::ArenaStringPtr appeui_;
  ::google::protobuf::uint32 frequencyband_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DataRecord : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.DataRecord) */ {
 public:
  DataRecord();
  virtual ~DataRecord();

  DataRecord(const DataRecord& from);

  inline DataRecord& operator=(const DataRecord& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DataRecord(DataRecord&& from) noexcept
    : DataRecord() {
    *this = ::std::move(from);
  }

  inline DataRecord& operator=(DataRecord&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DataRecord& default_instance();

  static inline const DataRecord* internal_default_instance() {
    return reinterpret_cast<const DataRecord*>(
               &_DataRecord_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(DataRecord* other);
  friend void swap(DataRecord& a, DataRecord& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DataRecord* New() const PROTOBUF_FINAL { return New(NULL); }

  DataRecord* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DataRecord& from);
  void MergeFrom(const DataRecord& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DataRecord* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fk_data.ModuleInfo modules = 6;
  int modules_size() const;
  void clear_modules();
  static const int kModulesFieldNumber = 6;
  const ::fk_data::ModuleInfo& modules(int index) const;
  ::fk_data::ModuleInfo* mutable_modules(int index);
  ::fk_data::ModuleInfo* add_modules();
  ::google::protobuf::RepeatedPtrField< ::fk_data::ModuleInfo >*
      mutable_modules();
  const ::google::protobuf::RepeatedPtrField< ::fk_data::ModuleInfo >&
      modules() const;

  // .fk_data.LoggedReading loggedReading = 1;
  bool has_loggedreading() const;
  void clear_loggedreading();
  static const int kLoggedReadingFieldNumber = 1;
  const ::fk_data::LoggedReading& loggedreading() const;
  ::fk_data::LoggedReading* mutable_loggedreading();
  ::fk_data::LoggedReading* release_loggedreading();
  void set_allocated_loggedreading(::fk_data::LoggedReading* loggedreading);

  // .fk_data.Metadata metadata = 2;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 2;
  const ::fk_data::Metadata& metadata() const;
  ::fk_data::Metadata* mutable_metadata();
  ::fk_data::Metadata* release_metadata();
  void set_allocated_metadata(::fk_data::Metadata* metadata);

  // .fk_data.LogMessage log = 3;
  bool has_log() const;
  void clear_log();
  static const int kLogFieldNumber = 3;
  const ::fk_data::LogMessage& log() const;
  ::fk_data::LogMessage* mutable_log();
  ::fk_data::LogMessage* release_log();
  void set_allocated_log(::fk_data::LogMessage* log);

  // .fk_data.Status status = 4;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  const ::fk_data::Status& status() const;
  ::fk_data::Status* mutable_status();
  ::fk_data::Status* release_status();
  void set_allocated_status(::fk_data::Status* status);

  // .fk_data.Readings readings = 5;
  bool has_readings() const;
  void clear_readings();
  static const int kReadingsFieldNumber = 5;
  const ::fk_data::Readings& readings() const;
  ::fk_data::Readings* mutable_readings();
  ::fk_data::Readings* release_readings();
  void set_allocated_readings(::fk_data::Readings* readings);

  // .fk_data.Schedule schedule = 7;
  bool has_schedule() const;
  void clear_schedule();
  static const int kScheduleFieldNumber = 7;
  const ::fk_data::Schedule& schedule() const;
  ::fk_data::Schedule* mutable_schedule();
  ::fk_data::Schedule* release_schedule();
  void set_allocated_schedule(::fk_data::Schedule* schedule);

  // .fk_data.Identity identity = 9;
  bool has_identity() const;
  void clear_identity();
  static const int kIdentityFieldNumber = 9;
  const ::fk_data::Identity& identity() const;
  ::fk_data::Identity* mutable_identity();
  ::fk_data::Identity* release_identity();
  void set_allocated_identity(::fk_data::Identity* identity);

  // .fk_data.Condition condition = 10;
  bool has_condition() const;
  void clear_condition();
  static const int kConditionFieldNumber = 10;
  const ::fk_data::Condition& condition() const;
  ::fk_data::Condition* mutable_condition();
  ::fk_data::Condition* release_condition();
  void set_allocated_condition(::fk_data::Condition* condition);

  // .fk_data.LoraSettings lora = 11;
  bool has_lora() const;
  void clear_lora();
  static const int kLoraFieldNumber = 11;
  const ::fk_data::LoraSettings& lora() const;
  ::fk_data::LoraSettings* mutable_lora();
  ::fk_data::LoraSettings* release_lora();
  void set_allocated_lora(::fk_data::LoraSettings* lora);

  // .fk_data.NetworkSettings network = 12;
  bool has_network() const;
  void clear_network();
  static const int kNetworkFieldNumber = 12;
  const ::fk_data::NetworkSettings& network() const;
  ::fk_data::NetworkSettings* mutable_network();
  ::fk_data::NetworkSettings* release_network();
  void set_allocated_network(::fk_data::NetworkSettings* network);

  // uint64 meta = 8;
  void clear_meta();
  static const int kMetaFieldNumber = 8;
  ::google::protobuf::uint64 meta() const;
  void set_meta(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:fk_data.DataRecord)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::fk_data::ModuleInfo > modules_;
  ::fk_data::LoggedReading* loggedreading_;
  ::fk_data::Metadata* metadata_;
  ::fk_data::LogMessage* log_;
  ::fk_data::Status* status_;
  ::fk_data::Readings* readings_;
  ::fk_data::Schedule* schedule_;
  ::fk_data::Identity* identity_;
  ::fk_data::Condition* condition_;
  ::fk_data::LoraSettings* lora_;
  ::fk_data::NetworkSettings* network_;
  ::google::protobuf::uint64 meta_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SignedRecord : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.SignedRecord) */ {
 public:
  SignedRecord();
  virtual ~SignedRecord();

  SignedRecord(const SignedRecord& from);

  inline SignedRecord& operator=(const SignedRecord& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignedRecord(SignedRecord&& from) noexcept
    : SignedRecord() {
    *this = ::std::move(from);
  }

  inline SignedRecord& operator=(SignedRecord&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SignedRecord& default_instance();

  static inline const SignedRecord* internal_default_instance() {
    return reinterpret_cast<const SignedRecord*>(
               &_SignedRecord_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(SignedRecord* other);
  friend void swap(SignedRecord& a, SignedRecord& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignedRecord* New() const PROTOBUF_FINAL { return New(NULL); }

  SignedRecord* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SignedRecord& from);
  void MergeFrom(const SignedRecord& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SignedRecord* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 3;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // bytes hash = 4;
  void clear_hash();
  static const int kHashFieldNumber = 4;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // uint64 time = 2;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // uint64 record = 5;
  void clear_record();
  static const int kRecordFieldNumber = 5;
  ::google::protobuf::uint64 record() const;
  void set_record(::google::protobuf::uint64 value);

  // .fk_data.SignedRecordKind kind = 1;
  void clear_kind();
  static const int kKindFieldNumber = 1;
  ::fk_data::SignedRecordKind kind() const;
  void set_kind(::fk_data::SignedRecordKind value);

  // @@protoc_insertion_point(class_scope:fk_data.SignedRecord)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint64 record_;
  int kind_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoraRecord : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fk_data.LoraRecord) */ {
 public:
  LoraRecord();
  virtual ~LoraRecord();

  LoraRecord(const LoraRecord& from);

  inline LoraRecord& operator=(const LoraRecord& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoraRecord(LoraRecord&& from) noexcept
    : LoraRecord() {
    *this = ::std::move(from);
  }

  inline LoraRecord& operator=(LoraRecord&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoraRecord& default_instance();

  static inline const LoraRecord* internal_default_instance() {
    return reinterpret_cast<const LoraRecord*>(
               &_LoraRecord_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(LoraRecord* other);
  friend void swap(LoraRecord& a, LoraRecord& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoraRecord* New() const PROTOBUF_FINAL { return New(NULL); }

  LoraRecord* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoraRecord& from);
  void MergeFrom(const LoraRecord& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoraRecord* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float values = 6;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 6;
  float values(int index) const;
  void set_values(int index, float value);
  void add_values(float value);
  const ::google::protobuf::RepeatedField< float >&
      values() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_values();

  // bytes deviceId = 1;
  void clear_deviceid();
  static const int kDeviceIdFieldNumber = 1;
  const ::std::string& deviceid() const;
  void set_deviceid(const ::std::string& value);
  #if LANG_CXX11
  void set_deviceid(::std::string&& value);
  #endif
  void set_deviceid(const char* value);
  void set_deviceid(const void* value, size_t size);
  ::std::string* mutable_deviceid();
  ::std::string* release_deviceid();
  void set_allocated_deviceid(::std::string* deviceid);

  // bytes data = 7;
  void clear_data();
  static const int kDataFieldNumber = 7;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // uint64 time = 2;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // uint64 number = 3;
  void clear_number();
  static const int kNumberFieldNumber = 3;
  ::google::protobuf::uint64 number() const;
  void set_number(::google::protobuf::uint64 value);

  // uint64 sensor = 5;
  void clear_sensor();
  static const int kSensorFieldNumber = 5;
  ::google::protobuf::uint64 sensor() const;
  void set_sensor(::google::protobuf::uint64 value);

  // uint32 module = 4;
  void clear_module();
  static const int kModuleFieldNumber = 4;
  ::google::protobuf::uint32 module() const;
  void set_module(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fk_data.LoraRecord)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > values_;
  mutable int _values_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr deviceid_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint64 number_;
  ::google::protobuf::uint64 sensor_;
  ::google::protobuf::uint32 module_;
  mutable int _cached_size_;
  friend struct protobuf_fk_2ddata_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DeviceLocation

// uint32 enabled = 7;
inline void DeviceLocation::clear_enabled() {
  enabled_ = 0u;
}
inline ::google::protobuf::uint32 DeviceLocation::enabled() const {
  // @@protoc_insertion_point(field_get:fk_data.DeviceLocation.enabled)
  return enabled_;
}
inline void DeviceLocation::set_enabled(::google::protobuf::uint32 value) {
  
  enabled_ = value;
  // @@protoc_insertion_point(field_set:fk_data.DeviceLocation.enabled)
}

// uint32 fix = 1;
inline void DeviceLocation::clear_fix() {
  fix_ = 0u;
}
inline ::google::protobuf::uint32 DeviceLocation::fix() const {
  // @@protoc_insertion_point(field_get:fk_data.DeviceLocation.fix)
  return fix_;
}
inline void DeviceLocation::set_fix(::google::protobuf::uint32 value) {
  
  fix_ = value;
  // @@protoc_insertion_point(field_set:fk_data.DeviceLocation.fix)
}

// uint64 time = 2;
inline void DeviceLocation::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 DeviceLocation::time() const {
  // @@protoc_insertion_point(field_get:fk_data.DeviceLocation.time)
  return time_;
}
inline void DeviceLocation::set_time(::google::protobuf::uint64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:fk_data.DeviceLocation.time)
}

// float longitude = 3;
inline void DeviceLocation::clear_longitude() {
  longitude_ = 0;
}
inline float DeviceLocation::longitude() const {
  // @@protoc_insertion_point(field_get:fk_data.DeviceLocation.longitude)
  return longitude_;
}
inline void DeviceLocation::set_longitude(float value) {
  
  longitude_ = value;
  // @@protoc_insertion_point(field_set:fk_data.DeviceLocation.longitude)
}

// float latitude = 4;
inline void DeviceLocation::clear_latitude() {
  latitude_ = 0;
}
inline float DeviceLocation::latitude() const {
  // @@protoc_insertion_point(field_get:fk_data.DeviceLocation.latitude)
  return latitude_;
}
inline void DeviceLocation::set_latitude(float value) {
  
  latitude_ = value;
  // @@protoc_insertion_point(field_set:fk_data.DeviceLocation.latitude)
}

// float altitude = 5;
inline void DeviceLocation::clear_altitude() {
  altitude_ = 0;
}
inline float DeviceLocation::altitude() const {
  // @@protoc_insertion_point(field_get:fk_data.DeviceLocation.altitude)
  return altitude_;
}
inline void DeviceLocation::set_altitude(float value) {
  
  altitude_ = value;
  // @@protoc_insertion_point(field_set:fk_data.DeviceLocation.altitude)
}

// repeated float coordinates = 6;
inline int DeviceLocation::coordinates_size() const {
  return coordinates_.size();
}
inline void DeviceLocation::clear_coordinates() {
  coordinates_.Clear();
}
inline float DeviceLocation::coordinates(int index) const {
  // @@protoc_insertion_point(field_get:fk_data.DeviceLocation.coordinates)
  return coordinates_.Get(index);
}
inline void DeviceLocation::set_coordinates(int index, float value) {
  coordinates_.Set(index, value);
  // @@protoc_insertion_point(field_set:fk_data.DeviceLocation.coordinates)
}
inline void DeviceLocation::add_coordinates(float value) {
  coordinates_.Add(value);
  // @@protoc_insertion_point(field_add:fk_data.DeviceLocation.coordinates)
}
inline const ::google::protobuf::RepeatedField< float >&
DeviceLocation::coordinates() const {
  // @@protoc_insertion_point(field_list:fk_data.DeviceLocation.coordinates)
  return coordinates_;
}
inline ::google::protobuf::RepeatedField< float >*
DeviceLocation::mutable_coordinates() {
  // @@protoc_insertion_point(field_mutable_list:fk_data.DeviceLocation.coordinates)
  return &coordinates_;
}

// uint32 satellites = 8;
inline void DeviceLocation::clear_satellites() {
  satellites_ = 0u;
}
inline ::google::protobuf::uint32 DeviceLocation::satellites() const {
  // @@protoc_insertion_point(field_get:fk_data.DeviceLocation.satellites)
  return satellites_;
}
inline void DeviceLocation::set_satellites(::google::protobuf::uint32 value) {
  
  satellites_ = value;
  // @@protoc_insertion_point(field_set:fk_data.DeviceLocation.satellites)
}

// uint32 hdop = 9;
inline void DeviceLocation::clear_hdop() {
  hdop_ = 0u;
}
inline ::google::protobuf::uint32 DeviceLocation::hdop() const {
  // @@protoc_insertion_point(field_get:fk_data.DeviceLocation.hdop)
  return hdop_;
}
inline void DeviceLocation::set_hdop(::google::protobuf::uint32 value) {
  
  hdop_ = value;
  // @@protoc_insertion_point(field_set:fk_data.DeviceLocation.hdop)
}

// -------------------------------------------------------------------

// SensorReading

// uint32 reading = 1;
inline void SensorReading::clear_reading() {
  reading_ = 0u;
}
inline ::google::protobuf::uint32 SensorReading::reading() const {
  // @@protoc_insertion_point(field_get:fk_data.SensorReading.reading)
  return reading_;
}
inline void SensorReading::set_reading(::google::protobuf::uint32 value) {
  
  reading_ = value;
  // @@protoc_insertion_point(field_set:fk_data.SensorReading.reading)
}

// uint64 time = 2;
inline void SensorReading::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SensorReading::time() const {
  // @@protoc_insertion_point(field_get:fk_data.SensorReading.time)
  return time_;
}
inline void SensorReading::set_time(::google::protobuf::uint64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:fk_data.SensorReading.time)
}

// uint32 sensor = 3;
inline void SensorReading::clear_sensor() {
  sensor_ = 0u;
}
inline ::google::protobuf::uint32 SensorReading::sensor() const {
  // @@protoc_insertion_point(field_get:fk_data.SensorReading.sensor)
  return sensor_;
}
inline void SensorReading::set_sensor(::google::protobuf::uint32 value) {
  
  sensor_ = value;
  // @@protoc_insertion_point(field_set:fk_data.SensorReading.sensor)
}

// float value = 4;
inline void SensorReading::clear_value() {
  value_ = 0;
}
inline float SensorReading::value() const {
  // @@protoc_insertion_point(field_get:fk_data.SensorReading.value)
  return value_;
}
inline void SensorReading::set_value(float value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:fk_data.SensorReading.value)
}

// -------------------------------------------------------------------

// LoggedReading

// uint32 version = 1;
inline void LoggedReading::clear_version() {
  version_ = 0u;
}
inline ::google::protobuf::uint32 LoggedReading::version() const {
  // @@protoc_insertion_point(field_get:fk_data.LoggedReading.version)
  return version_;
}
inline void LoggedReading::set_version(::google::protobuf::uint32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:fk_data.LoggedReading.version)
}

// .fk_data.DeviceLocation location = 2;
inline bool LoggedReading::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void LoggedReading::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
inline const ::fk_data::DeviceLocation& LoggedReading::location() const {
  const ::fk_data::DeviceLocation* p = location_;
  // @@protoc_insertion_point(field_get:fk_data.LoggedReading.location)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::DeviceLocation*>(
      &::fk_data::_DeviceLocation_default_instance_);
}
inline ::fk_data::DeviceLocation* LoggedReading::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::fk_data::DeviceLocation;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.LoggedReading.location)
  return location_;
}
inline ::fk_data::DeviceLocation* LoggedReading::release_location() {
  // @@protoc_insertion_point(field_release:fk_data.LoggedReading.location)
  
  ::fk_data::DeviceLocation* temp = location_;
  location_ = NULL;
  return temp;
}
inline void LoggedReading::set_allocated_location(::fk_data::DeviceLocation* location) {
  delete location_;
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.LoggedReading.location)
}

// .fk_data.SensorReading reading = 3;
inline bool LoggedReading::has_reading() const {
  return this != internal_default_instance() && reading_ != NULL;
}
inline void LoggedReading::clear_reading() {
  if (GetArenaNoVirtual() == NULL && reading_ != NULL) delete reading_;
  reading_ = NULL;
}
inline const ::fk_data::SensorReading& LoggedReading::reading() const {
  const ::fk_data::SensorReading* p = reading_;
  // @@protoc_insertion_point(field_get:fk_data.LoggedReading.reading)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::SensorReading*>(
      &::fk_data::_SensorReading_default_instance_);
}
inline ::fk_data::SensorReading* LoggedReading::mutable_reading() {
  
  if (reading_ == NULL) {
    reading_ = new ::fk_data::SensorReading;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.LoggedReading.reading)
  return reading_;
}
inline ::fk_data::SensorReading* LoggedReading::release_reading() {
  // @@protoc_insertion_point(field_release:fk_data.LoggedReading.reading)
  
  ::fk_data::SensorReading* temp = reading_;
  reading_ = NULL;
  return temp;
}
inline void LoggedReading::set_allocated_reading(::fk_data::SensorReading* reading) {
  delete reading_;
  reading_ = reading;
  if (reading) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.LoggedReading.reading)
}

// -------------------------------------------------------------------

// SensorAndValue

// uint32 sensor = 1;
inline void SensorAndValue::clear_sensor() {
  sensor_ = 0u;
}
inline ::google::protobuf::uint32 SensorAndValue::sensor() const {
  // @@protoc_insertion_point(field_get:fk_data.SensorAndValue.sensor)
  return sensor_;
}
inline void SensorAndValue::set_sensor(::google::protobuf::uint32 value) {
  
  sensor_ = value;
  // @@protoc_insertion_point(field_set:fk_data.SensorAndValue.sensor)
}

// float value = 2;
inline void SensorAndValue::clear_value() {
  value_ = 0;
}
inline float SensorAndValue::value() const {
  // @@protoc_insertion_point(field_get:fk_data.SensorAndValue.value)
  return value_;
}
inline void SensorAndValue::set_value(float value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:fk_data.SensorAndValue.value)
}

// -------------------------------------------------------------------

// ModuleHeader

// uint32 manufacturer = 1;
inline void ModuleHeader::clear_manufacturer() {
  manufacturer_ = 0u;
}
inline ::google::protobuf::uint32 ModuleHeader::manufacturer() const {
  // @@protoc_insertion_point(field_get:fk_data.ModuleHeader.manufacturer)
  return manufacturer_;
}
inline void ModuleHeader::set_manufacturer(::google::protobuf::uint32 value) {
  
  manufacturer_ = value;
  // @@protoc_insertion_point(field_set:fk_data.ModuleHeader.manufacturer)
}

// uint32 kind = 2;
inline void ModuleHeader::clear_kind() {
  kind_ = 0u;
}
inline ::google::protobuf::uint32 ModuleHeader::kind() const {
  // @@protoc_insertion_point(field_get:fk_data.ModuleHeader.kind)
  return kind_;
}
inline void ModuleHeader::set_kind(::google::protobuf::uint32 value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:fk_data.ModuleHeader.kind)
}

// uint32 version = 3;
inline void ModuleHeader::clear_version() {
  version_ = 0u;
}
inline ::google::protobuf::uint32 ModuleHeader::version() const {
  // @@protoc_insertion_point(field_get:fk_data.ModuleHeader.version)
  return version_;
}
inline void ModuleHeader::set_version(::google::protobuf::uint32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:fk_data.ModuleHeader.version)
}

// -------------------------------------------------------------------

// ModuleInfo

// uint32 position = 1;
inline void ModuleInfo::clear_position() {
  position_ = 0u;
}
inline ::google::protobuf::uint32 ModuleInfo::position() const {
  // @@protoc_insertion_point(field_get:fk_data.ModuleInfo.position)
  return position_;
}
inline void ModuleInfo::set_position(::google::protobuf::uint32 value) {
  
  position_ = value;
  // @@protoc_insertion_point(field_set:fk_data.ModuleInfo.position)
}

// uint32 address = 2;
inline void ModuleInfo::clear_address() {
  address_ = 0u;
}
inline ::google::protobuf::uint32 ModuleInfo::address() const {
  // @@protoc_insertion_point(field_get:fk_data.ModuleInfo.address)
  return address_;
}
inline void ModuleInfo::set_address(::google::protobuf::uint32 value) {
  
  address_ = value;
  // @@protoc_insertion_point(field_set:fk_data.ModuleInfo.address)
}

// string name = 3;
inline void ModuleInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ModuleInfo::name() const {
  // @@protoc_insertion_point(field_get:fk_data.ModuleInfo.name)
  return name_.GetNoArena();
}
inline void ModuleInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.ModuleInfo.name)
}
#if LANG_CXX11
inline void ModuleInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.ModuleInfo.name)
}
#endif
inline void ModuleInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.ModuleInfo.name)
}
inline void ModuleInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.ModuleInfo.name)
}
inline ::std::string* ModuleInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.ModuleInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModuleInfo::release_name() {
  // @@protoc_insertion_point(field_release:fk_data.ModuleInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModuleInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:fk_data.ModuleInfo.name)
}

// .fk_data.ModuleHeader header = 4;
inline bool ModuleInfo::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ModuleInfo::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::fk_data::ModuleHeader& ModuleInfo::header() const {
  const ::fk_data::ModuleHeader* p = header_;
  // @@protoc_insertion_point(field_get:fk_data.ModuleInfo.header)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::ModuleHeader*>(
      &::fk_data::_ModuleHeader_default_instance_);
}
inline ::fk_data::ModuleHeader* ModuleInfo::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::fk_data::ModuleHeader;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.ModuleInfo.header)
  return header_;
}
inline ::fk_data::ModuleHeader* ModuleInfo::release_header() {
  // @@protoc_insertion_point(field_release:fk_data.ModuleInfo.header)
  
  ::fk_data::ModuleHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ModuleInfo::set_allocated_header(::fk_data::ModuleHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.ModuleInfo.header)
}

// .fk_data.Firmware firmware = 5;
inline bool ModuleInfo::has_firmware() const {
  return this != internal_default_instance() && firmware_ != NULL;
}
inline void ModuleInfo::clear_firmware() {
  if (GetArenaNoVirtual() == NULL && firmware_ != NULL) delete firmware_;
  firmware_ = NULL;
}
inline const ::fk_data::Firmware& ModuleInfo::firmware() const {
  const ::fk_data::Firmware* p = firmware_;
  // @@protoc_insertion_point(field_get:fk_data.ModuleInfo.firmware)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::Firmware*>(
      &::fk_data::_Firmware_default_instance_);
}
inline ::fk_data::Firmware* ModuleInfo::mutable_firmware() {
  
  if (firmware_ == NULL) {
    firmware_ = new ::fk_data::Firmware;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.ModuleInfo.firmware)
  return firmware_;
}
inline ::fk_data::Firmware* ModuleInfo::release_firmware() {
  // @@protoc_insertion_point(field_release:fk_data.ModuleInfo.firmware)
  
  ::fk_data::Firmware* temp = firmware_;
  firmware_ = NULL;
  return temp;
}
inline void ModuleInfo::set_allocated_firmware(::fk_data::Firmware* firmware) {
  delete firmware_;
  firmware_ = firmware;
  if (firmware) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.ModuleInfo.firmware)
}

// repeated .fk_data.SensorInfo sensors = 6;
inline int ModuleInfo::sensors_size() const {
  return sensors_.size();
}
inline void ModuleInfo::clear_sensors() {
  sensors_.Clear();
}
inline const ::fk_data::SensorInfo& ModuleInfo::sensors(int index) const {
  // @@protoc_insertion_point(field_get:fk_data.ModuleInfo.sensors)
  return sensors_.Get(index);
}
inline ::fk_data::SensorInfo* ModuleInfo::mutable_sensors(int index) {
  // @@protoc_insertion_point(field_mutable:fk_data.ModuleInfo.sensors)
  return sensors_.Mutable(index);
}
inline ::fk_data::SensorInfo* ModuleInfo::add_sensors() {
  // @@protoc_insertion_point(field_add:fk_data.ModuleInfo.sensors)
  return sensors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fk_data::SensorInfo >*
ModuleInfo::mutable_sensors() {
  // @@protoc_insertion_point(field_mutable_list:fk_data.ModuleInfo.sensors)
  return &sensors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fk_data::SensorInfo >&
ModuleInfo::sensors() const {
  // @@protoc_insertion_point(field_list:fk_data.ModuleInfo.sensors)
  return sensors_;
}

// bytes id = 7;
inline void ModuleInfo::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ModuleInfo::id() const {
  // @@protoc_insertion_point(field_get:fk_data.ModuleInfo.id)
  return id_.GetNoArena();
}
inline void ModuleInfo::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.ModuleInfo.id)
}
#if LANG_CXX11
inline void ModuleInfo::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.ModuleInfo.id)
}
#endif
inline void ModuleInfo::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.ModuleInfo.id)
}
inline void ModuleInfo::set_id(const void* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.ModuleInfo.id)
}
inline ::std::string* ModuleInfo::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.ModuleInfo.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModuleInfo::release_id() {
  // @@protoc_insertion_point(field_release:fk_data.ModuleInfo.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModuleInfo::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:fk_data.ModuleInfo.id)
}

// uint32 flags = 8;
inline void ModuleInfo::clear_flags() {
  flags_ = 0u;
}
inline ::google::protobuf::uint32 ModuleInfo::flags() const {
  // @@protoc_insertion_point(field_get:fk_data.ModuleInfo.flags)
  return flags_;
}
inline void ModuleInfo::set_flags(::google::protobuf::uint32 value) {
  
  flags_ = value;
  // @@protoc_insertion_point(field_set:fk_data.ModuleInfo.flags)
}

// -------------------------------------------------------------------

// SensorInfo

// uint32 number = 1;
inline void SensorInfo::clear_number() {
  number_ = 0u;
}
inline ::google::protobuf::uint32 SensorInfo::number() const {
  // @@protoc_insertion_point(field_get:fk_data.SensorInfo.number)
  return number_;
}
inline void SensorInfo::set_number(::google::protobuf::uint32 value) {
  
  number_ = value;
  // @@protoc_insertion_point(field_set:fk_data.SensorInfo.number)
}

// string name = 2;
inline void SensorInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SensorInfo::name() const {
  // @@protoc_insertion_point(field_get:fk_data.SensorInfo.name)
  return name_.GetNoArena();
}
inline void SensorInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.SensorInfo.name)
}
#if LANG_CXX11
inline void SensorInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.SensorInfo.name)
}
#endif
inline void SensorInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.SensorInfo.name)
}
inline void SensorInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.SensorInfo.name)
}
inline ::std::string* SensorInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.SensorInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SensorInfo::release_name() {
  // @@protoc_insertion_point(field_release:fk_data.SensorInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SensorInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:fk_data.SensorInfo.name)
}

// string unitOfMeasure = 3;
inline void SensorInfo::clear_unitofmeasure() {
  unitofmeasure_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SensorInfo::unitofmeasure() const {
  // @@protoc_insertion_point(field_get:fk_data.SensorInfo.unitOfMeasure)
  return unitofmeasure_.GetNoArena();
}
inline void SensorInfo::set_unitofmeasure(const ::std::string& value) {
  
  unitofmeasure_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.SensorInfo.unitOfMeasure)
}
#if LANG_CXX11
inline void SensorInfo::set_unitofmeasure(::std::string&& value) {
  
  unitofmeasure_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.SensorInfo.unitOfMeasure)
}
#endif
inline void SensorInfo::set_unitofmeasure(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  unitofmeasure_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.SensorInfo.unitOfMeasure)
}
inline void SensorInfo::set_unitofmeasure(const char* value, size_t size) {
  
  unitofmeasure_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.SensorInfo.unitOfMeasure)
}
inline ::std::string* SensorInfo::mutable_unitofmeasure() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.SensorInfo.unitOfMeasure)
  return unitofmeasure_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SensorInfo::release_unitofmeasure() {
  // @@protoc_insertion_point(field_release:fk_data.SensorInfo.unitOfMeasure)
  
  return unitofmeasure_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SensorInfo::set_allocated_unitofmeasure(::std::string* unitofmeasure) {
  if (unitofmeasure != NULL) {
    
  } else {
    
  }
  unitofmeasure_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), unitofmeasure);
  // @@protoc_insertion_point(field_set_allocated:fk_data.SensorInfo.unitOfMeasure)
}

// uint32 flags = 4;
inline void SensorInfo::clear_flags() {
  flags_ = 0u;
}
inline ::google::protobuf::uint32 SensorInfo::flags() const {
  // @@protoc_insertion_point(field_get:fk_data.SensorInfo.flags)
  return flags_;
}
inline void SensorInfo::set_flags(::google::protobuf::uint32 value) {
  
  flags_ = value;
  // @@protoc_insertion_point(field_set:fk_data.SensorInfo.flags)
}

// -------------------------------------------------------------------

// Firmware

// string git = 1;
inline void Firmware::clear_git() {
  git_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Firmware::git() const {
  // @@protoc_insertion_point(field_get:fk_data.Firmware.git)
  return git_.GetNoArena();
}
inline void Firmware::set_git(const ::std::string& value) {
  
  git_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.Firmware.git)
}
#if LANG_CXX11
inline void Firmware::set_git(::std::string&& value) {
  
  git_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.Firmware.git)
}
#endif
inline void Firmware::set_git(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  git_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.Firmware.git)
}
inline void Firmware::set_git(const char* value, size_t size) {
  
  git_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.Firmware.git)
}
inline ::std::string* Firmware::mutable_git() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.Firmware.git)
  return git_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Firmware::release_git() {
  // @@protoc_insertion_point(field_release:fk_data.Firmware.git)
  
  return git_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Firmware::set_allocated_git(::std::string* git) {
  if (git != NULL) {
    
  } else {
    
  }
  git_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), git);
  // @@protoc_insertion_point(field_set_allocated:fk_data.Firmware.git)
}

// string build = 2;
inline void Firmware::clear_build() {
  build_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Firmware::build() const {
  // @@protoc_insertion_point(field_get:fk_data.Firmware.build)
  return build_.GetNoArena();
}
inline void Firmware::set_build(const ::std::string& value) {
  
  build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.Firmware.build)
}
#if LANG_CXX11
inline void Firmware::set_build(::std::string&& value) {
  
  build_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.Firmware.build)
}
#endif
inline void Firmware::set_build(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.Firmware.build)
}
inline void Firmware::set_build(const char* value, size_t size) {
  
  build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.Firmware.build)
}
inline ::std::string* Firmware::mutable_build() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.Firmware.build)
  return build_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Firmware::release_build() {
  // @@protoc_insertion_point(field_release:fk_data.Firmware.build)
  
  return build_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Firmware::set_allocated_build(::std::string* build) {
  if (build != NULL) {
    
  } else {
    
  }
  build_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), build);
  // @@protoc_insertion_point(field_set_allocated:fk_data.Firmware.build)
}

// -------------------------------------------------------------------

// Metadata

// bytes deviceId = 1;
inline void Metadata::clear_deviceid() {
  deviceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Metadata::deviceid() const {
  // @@protoc_insertion_point(field_get:fk_data.Metadata.deviceId)
  return deviceid_.GetNoArena();
}
inline void Metadata::set_deviceid(const ::std::string& value) {
  
  deviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.Metadata.deviceId)
}
#if LANG_CXX11
inline void Metadata::set_deviceid(::std::string&& value) {
  
  deviceid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.Metadata.deviceId)
}
#endif
inline void Metadata::set_deviceid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  deviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.Metadata.deviceId)
}
inline void Metadata::set_deviceid(const void* value, size_t size) {
  
  deviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.Metadata.deviceId)
}
inline ::std::string* Metadata::mutable_deviceid() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.Metadata.deviceId)
  return deviceid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Metadata::release_deviceid() {
  // @@protoc_insertion_point(field_release:fk_data.Metadata.deviceId)
  
  return deviceid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Metadata::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid != NULL) {
    
  } else {
    
  }
  deviceid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), deviceid);
  // @@protoc_insertion_point(field_set_allocated:fk_data.Metadata.deviceId)
}

// uint64 time = 2;
inline void Metadata::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Metadata::time() const {
  // @@protoc_insertion_point(field_get:fk_data.Metadata.time)
  return time_;
}
inline void Metadata::set_time(::google::protobuf::uint64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:fk_data.Metadata.time)
}

// string git = 3;
inline void Metadata::clear_git() {
  git_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Metadata::git() const {
  // @@protoc_insertion_point(field_get:fk_data.Metadata.git)
  return git_.GetNoArena();
}
inline void Metadata::set_git(const ::std::string& value) {
  
  git_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.Metadata.git)
}
#if LANG_CXX11
inline void Metadata::set_git(::std::string&& value) {
  
  git_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.Metadata.git)
}
#endif
inline void Metadata::set_git(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  git_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.Metadata.git)
}
inline void Metadata::set_git(const char* value, size_t size) {
  
  git_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.Metadata.git)
}
inline ::std::string* Metadata::mutable_git() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.Metadata.git)
  return git_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Metadata::release_git() {
  // @@protoc_insertion_point(field_release:fk_data.Metadata.git)
  
  return git_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Metadata::set_allocated_git(::std::string* git) {
  if (git != NULL) {
    
  } else {
    
  }
  git_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), git);
  // @@protoc_insertion_point(field_set_allocated:fk_data.Metadata.git)
}

// string build = 7;
inline void Metadata::clear_build() {
  build_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Metadata::build() const {
  // @@protoc_insertion_point(field_get:fk_data.Metadata.build)
  return build_.GetNoArena();
}
inline void Metadata::set_build(const ::std::string& value) {
  
  build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.Metadata.build)
}
#if LANG_CXX11
inline void Metadata::set_build(::std::string&& value) {
  
  build_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.Metadata.build)
}
#endif
inline void Metadata::set_build(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.Metadata.build)
}
inline void Metadata::set_build(const char* value, size_t size) {
  
  build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.Metadata.build)
}
inline ::std::string* Metadata::mutable_build() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.Metadata.build)
  return build_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Metadata::release_build() {
  // @@protoc_insertion_point(field_release:fk_data.Metadata.build)
  
  return build_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Metadata::set_allocated_build(::std::string* build) {
  if (build != NULL) {
    
  } else {
    
  }
  build_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), build);
  // @@protoc_insertion_point(field_set_allocated:fk_data.Metadata.build)
}

// uint32 resetCause = 4;
inline void Metadata::clear_resetcause() {
  resetcause_ = 0u;
}
inline ::google::protobuf::uint32 Metadata::resetcause() const {
  // @@protoc_insertion_point(field_get:fk_data.Metadata.resetCause)
  return resetcause_;
}
inline void Metadata::set_resetcause(::google::protobuf::uint32 value) {
  
  resetcause_ = value;
  // @@protoc_insertion_point(field_set:fk_data.Metadata.resetCause)
}

// repeated .fk_data.SensorInfo sensors = 5;
inline int Metadata::sensors_size() const {
  return sensors_.size();
}
inline void Metadata::clear_sensors() {
  sensors_.Clear();
}
inline const ::fk_data::SensorInfo& Metadata::sensors(int index) const {
  // @@protoc_insertion_point(field_get:fk_data.Metadata.sensors)
  return sensors_.Get(index);
}
inline ::fk_data::SensorInfo* Metadata::mutable_sensors(int index) {
  // @@protoc_insertion_point(field_mutable:fk_data.Metadata.sensors)
  return sensors_.Mutable(index);
}
inline ::fk_data::SensorInfo* Metadata::add_sensors() {
  // @@protoc_insertion_point(field_add:fk_data.Metadata.sensors)
  return sensors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fk_data::SensorInfo >*
Metadata::mutable_sensors() {
  // @@protoc_insertion_point(field_mutable_list:fk_data.Metadata.sensors)
  return &sensors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fk_data::SensorInfo >&
Metadata::sensors() const {
  // @@protoc_insertion_point(field_list:fk_data.Metadata.sensors)
  return sensors_;
}

// repeated .fk_data.ModuleInfo modules = 6;
inline int Metadata::modules_size() const {
  return modules_.size();
}
inline void Metadata::clear_modules() {
  modules_.Clear();
}
inline const ::fk_data::ModuleInfo& Metadata::modules(int index) const {
  // @@protoc_insertion_point(field_get:fk_data.Metadata.modules)
  return modules_.Get(index);
}
inline ::fk_data::ModuleInfo* Metadata::mutable_modules(int index) {
  // @@protoc_insertion_point(field_mutable:fk_data.Metadata.modules)
  return modules_.Mutable(index);
}
inline ::fk_data::ModuleInfo* Metadata::add_modules() {
  // @@protoc_insertion_point(field_add:fk_data.Metadata.modules)
  return modules_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fk_data::ModuleInfo >*
Metadata::mutable_modules() {
  // @@protoc_insertion_point(field_mutable_list:fk_data.Metadata.modules)
  return &modules_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fk_data::ModuleInfo >&
Metadata::modules() const {
  // @@protoc_insertion_point(field_list:fk_data.Metadata.modules)
  return modules_;
}

// .fk_data.Firmware firmware = 8;
inline bool Metadata::has_firmware() const {
  return this != internal_default_instance() && firmware_ != NULL;
}
inline void Metadata::clear_firmware() {
  if (GetArenaNoVirtual() == NULL && firmware_ != NULL) delete firmware_;
  firmware_ = NULL;
}
inline const ::fk_data::Firmware& Metadata::firmware() const {
  const ::fk_data::Firmware* p = firmware_;
  // @@protoc_insertion_point(field_get:fk_data.Metadata.firmware)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::Firmware*>(
      &::fk_data::_Firmware_default_instance_);
}
inline ::fk_data::Firmware* Metadata::mutable_firmware() {
  
  if (firmware_ == NULL) {
    firmware_ = new ::fk_data::Firmware;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.Metadata.firmware)
  return firmware_;
}
inline ::fk_data::Firmware* Metadata::release_firmware() {
  // @@protoc_insertion_point(field_release:fk_data.Metadata.firmware)
  
  ::fk_data::Firmware* temp = firmware_;
  firmware_ = NULL;
  return temp;
}
inline void Metadata::set_allocated_firmware(::fk_data::Firmware* firmware) {
  delete firmware_;
  firmware_ = firmware;
  if (firmware) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.Metadata.firmware)
}

// bytes generation = 9;
inline void Metadata::clear_generation() {
  generation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Metadata::generation() const {
  // @@protoc_insertion_point(field_get:fk_data.Metadata.generation)
  return generation_.GetNoArena();
}
inline void Metadata::set_generation(const ::std::string& value) {
  
  generation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.Metadata.generation)
}
#if LANG_CXX11
inline void Metadata::set_generation(::std::string&& value) {
  
  generation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.Metadata.generation)
}
#endif
inline void Metadata::set_generation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  generation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.Metadata.generation)
}
inline void Metadata::set_generation(const void* value, size_t size) {
  
  generation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.Metadata.generation)
}
inline ::std::string* Metadata::mutable_generation() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.Metadata.generation)
  return generation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Metadata::release_generation() {
  // @@protoc_insertion_point(field_release:fk_data.Metadata.generation)
  
  return generation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Metadata::set_allocated_generation(::std::string* generation) {
  if (generation != NULL) {
    
  } else {
    
  }
  generation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), generation);
  // @@protoc_insertion_point(field_set_allocated:fk_data.Metadata.generation)
}

// -------------------------------------------------------------------

// Status

// uint64 time = 1;
inline void Status::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Status::time() const {
  // @@protoc_insertion_point(field_get:fk_data.Status.time)
  return time_;
}
inline void Status::set_time(::google::protobuf::uint64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:fk_data.Status.time)
}

// uint32 uptime = 2;
inline void Status::clear_uptime() {
  uptime_ = 0u;
}
inline ::google::protobuf::uint32 Status::uptime() const {
  // @@protoc_insertion_point(field_get:fk_data.Status.uptime)
  return uptime_;
}
inline void Status::set_uptime(::google::protobuf::uint32 value) {
  
  uptime_ = value;
  // @@protoc_insertion_point(field_set:fk_data.Status.uptime)
}

// float battery = 3;
inline void Status::clear_battery() {
  battery_ = 0;
}
inline float Status::battery() const {
  // @@protoc_insertion_point(field_get:fk_data.Status.battery)
  return battery_;
}
inline void Status::set_battery(float value) {
  
  battery_ = value;
  // @@protoc_insertion_point(field_set:fk_data.Status.battery)
}

// uint32 memory = 4;
inline void Status::clear_memory() {
  memory_ = 0u;
}
inline ::google::protobuf::uint32 Status::memory() const {
  // @@protoc_insertion_point(field_get:fk_data.Status.memory)
  return memory_;
}
inline void Status::set_memory(::google::protobuf::uint32 value) {
  
  memory_ = value;
  // @@protoc_insertion_point(field_set:fk_data.Status.memory)
}

// uint64 busy = 5;
inline void Status::clear_busy() {
  busy_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Status::busy() const {
  // @@protoc_insertion_point(field_get:fk_data.Status.busy)
  return busy_;
}
inline void Status::set_busy(::google::protobuf::uint64 value) {
  
  busy_ = value;
  // @@protoc_insertion_point(field_set:fk_data.Status.busy)
}

// -------------------------------------------------------------------

// LogMessage

// uint64 time = 1;
inline void LogMessage::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 LogMessage::time() const {
  // @@protoc_insertion_point(field_get:fk_data.LogMessage.time)
  return time_;
}
inline void LogMessage::set_time(::google::protobuf::uint64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:fk_data.LogMessage.time)
}

// uint32 uptime = 2;
inline void LogMessage::clear_uptime() {
  uptime_ = 0u;
}
inline ::google::protobuf::uint32 LogMessage::uptime() const {
  // @@protoc_insertion_point(field_get:fk_data.LogMessage.uptime)
  return uptime_;
}
inline void LogMessage::set_uptime(::google::protobuf::uint32 value) {
  
  uptime_ = value;
  // @@protoc_insertion_point(field_set:fk_data.LogMessage.uptime)
}

// uint32 level = 3;
inline void LogMessage::clear_level() {
  level_ = 0u;
}
inline ::google::protobuf::uint32 LogMessage::level() const {
  // @@protoc_insertion_point(field_get:fk_data.LogMessage.level)
  return level_;
}
inline void LogMessage::set_level(::google::protobuf::uint32 value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:fk_data.LogMessage.level)
}

// string facility = 4;
inline void LogMessage::clear_facility() {
  facility_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogMessage::facility() const {
  // @@protoc_insertion_point(field_get:fk_data.LogMessage.facility)
  return facility_.GetNoArena();
}
inline void LogMessage::set_facility(const ::std::string& value) {
  
  facility_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.LogMessage.facility)
}
#if LANG_CXX11
inline void LogMessage::set_facility(::std::string&& value) {
  
  facility_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.LogMessage.facility)
}
#endif
inline void LogMessage::set_facility(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  facility_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.LogMessage.facility)
}
inline void LogMessage::set_facility(const char* value, size_t size) {
  
  facility_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.LogMessage.facility)
}
inline ::std::string* LogMessage::mutable_facility() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.LogMessage.facility)
  return facility_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogMessage::release_facility() {
  // @@protoc_insertion_point(field_release:fk_data.LogMessage.facility)
  
  return facility_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogMessage::set_allocated_facility(::std::string* facility) {
  if (facility != NULL) {
    
  } else {
    
  }
  facility_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), facility);
  // @@protoc_insertion_point(field_set_allocated:fk_data.LogMessage.facility)
}

// string message = 5;
inline void LogMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogMessage::message() const {
  // @@protoc_insertion_point(field_get:fk_data.LogMessage.message)
  return message_.GetNoArena();
}
inline void LogMessage::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.LogMessage.message)
}
#if LANG_CXX11
inline void LogMessage::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.LogMessage.message)
}
#endif
inline void LogMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.LogMessage.message)
}
inline void LogMessage::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.LogMessage.message)
}
inline ::std::string* LogMessage::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.LogMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogMessage::release_message() {
  // @@protoc_insertion_point(field_release:fk_data.LogMessage.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:fk_data.LogMessage.message)
}

// -------------------------------------------------------------------

// SensorGroup

// uint32 module = 1;
inline void SensorGroup::clear_module() {
  module_ = 0u;
}
inline ::google::protobuf::uint32 SensorGroup::module() const {
  // @@protoc_insertion_point(field_get:fk_data.SensorGroup.module)
  return module_;
}
inline void SensorGroup::set_module(::google::protobuf::uint32 value) {
  
  module_ = value;
  // @@protoc_insertion_point(field_set:fk_data.SensorGroup.module)
}

// repeated .fk_data.SensorAndValue readings = 2;
inline int SensorGroup::readings_size() const {
  return readings_.size();
}
inline void SensorGroup::clear_readings() {
  readings_.Clear();
}
inline const ::fk_data::SensorAndValue& SensorGroup::readings(int index) const {
  // @@protoc_insertion_point(field_get:fk_data.SensorGroup.readings)
  return readings_.Get(index);
}
inline ::fk_data::SensorAndValue* SensorGroup::mutable_readings(int index) {
  // @@protoc_insertion_point(field_mutable:fk_data.SensorGroup.readings)
  return readings_.Mutable(index);
}
inline ::fk_data::SensorAndValue* SensorGroup::add_readings() {
  // @@protoc_insertion_point(field_add:fk_data.SensorGroup.readings)
  return readings_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fk_data::SensorAndValue >*
SensorGroup::mutable_readings() {
  // @@protoc_insertion_point(field_mutable_list:fk_data.SensorGroup.readings)
  return &readings_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fk_data::SensorAndValue >&
SensorGroup::readings() const {
  // @@protoc_insertion_point(field_list:fk_data.SensorGroup.readings)
  return readings_;
}

// -------------------------------------------------------------------

// Readings

// uint64 time = 1;
inline void Readings::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Readings::time() const {
  // @@protoc_insertion_point(field_get:fk_data.Readings.time)
  return time_;
}
inline void Readings::set_time(::google::protobuf::uint64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:fk_data.Readings.time)
}

// uint32 reading = 2;
inline void Readings::clear_reading() {
  reading_ = 0u;
}
inline ::google::protobuf::uint32 Readings::reading() const {
  // @@protoc_insertion_point(field_get:fk_data.Readings.reading)
  return reading_;
}
inline void Readings::set_reading(::google::protobuf::uint32 value) {
  
  reading_ = value;
  // @@protoc_insertion_point(field_set:fk_data.Readings.reading)
}

// uint32 flags = 3;
inline void Readings::clear_flags() {
  flags_ = 0u;
}
inline ::google::protobuf::uint32 Readings::flags() const {
  // @@protoc_insertion_point(field_get:fk_data.Readings.flags)
  return flags_;
}
inline void Readings::set_flags(::google::protobuf::uint32 value) {
  
  flags_ = value;
  // @@protoc_insertion_point(field_set:fk_data.Readings.flags)
}

// uint32 meta = 6;
inline void Readings::clear_meta() {
  meta_ = 0u;
}
inline ::google::protobuf::uint32 Readings::meta() const {
  // @@protoc_insertion_point(field_get:fk_data.Readings.meta)
  return meta_;
}
inline void Readings::set_meta(::google::protobuf::uint32 value) {
  
  meta_ = value;
  // @@protoc_insertion_point(field_set:fk_data.Readings.meta)
}

// .fk_data.DeviceLocation location = 4;
inline bool Readings::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void Readings::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
inline const ::fk_data::DeviceLocation& Readings::location() const {
  const ::fk_data::DeviceLocation* p = location_;
  // @@protoc_insertion_point(field_get:fk_data.Readings.location)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::DeviceLocation*>(
      &::fk_data::_DeviceLocation_default_instance_);
}
inline ::fk_data::DeviceLocation* Readings::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::fk_data::DeviceLocation;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.Readings.location)
  return location_;
}
inline ::fk_data::DeviceLocation* Readings::release_location() {
  // @@protoc_insertion_point(field_release:fk_data.Readings.location)
  
  ::fk_data::DeviceLocation* temp = location_;
  location_ = NULL;
  return temp;
}
inline void Readings::set_allocated_location(::fk_data::DeviceLocation* location) {
  delete location_;
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.Readings.location)
}

// repeated .fk_data.SensorGroup sensorGroups = 5;
inline int Readings::sensorgroups_size() const {
  return sensorgroups_.size();
}
inline void Readings::clear_sensorgroups() {
  sensorgroups_.Clear();
}
inline const ::fk_data::SensorGroup& Readings::sensorgroups(int index) const {
  // @@protoc_insertion_point(field_get:fk_data.Readings.sensorGroups)
  return sensorgroups_.Get(index);
}
inline ::fk_data::SensorGroup* Readings::mutable_sensorgroups(int index) {
  // @@protoc_insertion_point(field_mutable:fk_data.Readings.sensorGroups)
  return sensorgroups_.Mutable(index);
}
inline ::fk_data::SensorGroup* Readings::add_sensorgroups() {
  // @@protoc_insertion_point(field_add:fk_data.Readings.sensorGroups)
  return sensorgroups_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fk_data::SensorGroup >*
Readings::mutable_sensorgroups() {
  // @@protoc_insertion_point(field_mutable_list:fk_data.Readings.sensorGroups)
  return &sensorgroups_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fk_data::SensorGroup >&
Readings::sensorgroups() const {
  // @@protoc_insertion_point(field_list:fk_data.Readings.sensorGroups)
  return sensorgroups_;
}

// -------------------------------------------------------------------

// JobSchedule

// bytes cron = 1;
inline void JobSchedule::clear_cron() {
  cron_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JobSchedule::cron() const {
  // @@protoc_insertion_point(field_get:fk_data.JobSchedule.cron)
  return cron_.GetNoArena();
}
inline void JobSchedule::set_cron(const ::std::string& value) {
  
  cron_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.JobSchedule.cron)
}
#if LANG_CXX11
inline void JobSchedule::set_cron(::std::string&& value) {
  
  cron_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.JobSchedule.cron)
}
#endif
inline void JobSchedule::set_cron(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cron_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.JobSchedule.cron)
}
inline void JobSchedule::set_cron(const void* value, size_t size) {
  
  cron_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.JobSchedule.cron)
}
inline ::std::string* JobSchedule::mutable_cron() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.JobSchedule.cron)
  return cron_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JobSchedule::release_cron() {
  // @@protoc_insertion_point(field_release:fk_data.JobSchedule.cron)
  
  return cron_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JobSchedule::set_allocated_cron(::std::string* cron) {
  if (cron != NULL) {
    
  } else {
    
  }
  cron_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cron);
  // @@protoc_insertion_point(field_set_allocated:fk_data.JobSchedule.cron)
}

// uint32 interval = 2;
inline void JobSchedule::clear_interval() {
  interval_ = 0u;
}
inline ::google::protobuf::uint32 JobSchedule::interval() const {
  // @@protoc_insertion_point(field_get:fk_data.JobSchedule.interval)
  return interval_;
}
inline void JobSchedule::set_interval(::google::protobuf::uint32 value) {
  
  interval_ = value;
  // @@protoc_insertion_point(field_set:fk_data.JobSchedule.interval)
}

// -------------------------------------------------------------------

// Schedule

// .fk_data.JobSchedule readings = 1;
inline bool Schedule::has_readings() const {
  return this != internal_default_instance() && readings_ != NULL;
}
inline void Schedule::clear_readings() {
  if (GetArenaNoVirtual() == NULL && readings_ != NULL) delete readings_;
  readings_ = NULL;
}
inline const ::fk_data::JobSchedule& Schedule::readings() const {
  const ::fk_data::JobSchedule* p = readings_;
  // @@protoc_insertion_point(field_get:fk_data.Schedule.readings)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::JobSchedule*>(
      &::fk_data::_JobSchedule_default_instance_);
}
inline ::fk_data::JobSchedule* Schedule::mutable_readings() {
  
  if (readings_ == NULL) {
    readings_ = new ::fk_data::JobSchedule;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.Schedule.readings)
  return readings_;
}
inline ::fk_data::JobSchedule* Schedule::release_readings() {
  // @@protoc_insertion_point(field_release:fk_data.Schedule.readings)
  
  ::fk_data::JobSchedule* temp = readings_;
  readings_ = NULL;
  return temp;
}
inline void Schedule::set_allocated_readings(::fk_data::JobSchedule* readings) {
  delete readings_;
  readings_ = readings;
  if (readings) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.Schedule.readings)
}

// .fk_data.JobSchedule network = 2;
inline bool Schedule::has_network() const {
  return this != internal_default_instance() && network_ != NULL;
}
inline void Schedule::clear_network() {
  if (GetArenaNoVirtual() == NULL && network_ != NULL) delete network_;
  network_ = NULL;
}
inline const ::fk_data::JobSchedule& Schedule::network() const {
  const ::fk_data::JobSchedule* p = network_;
  // @@protoc_insertion_point(field_get:fk_data.Schedule.network)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::JobSchedule*>(
      &::fk_data::_JobSchedule_default_instance_);
}
inline ::fk_data::JobSchedule* Schedule::mutable_network() {
  
  if (network_ == NULL) {
    network_ = new ::fk_data::JobSchedule;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.Schedule.network)
  return network_;
}
inline ::fk_data::JobSchedule* Schedule::release_network() {
  // @@protoc_insertion_point(field_release:fk_data.Schedule.network)
  
  ::fk_data::JobSchedule* temp = network_;
  network_ = NULL;
  return temp;
}
inline void Schedule::set_allocated_network(::fk_data::JobSchedule* network) {
  delete network_;
  network_ = network;
  if (network) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.Schedule.network)
}

// .fk_data.JobSchedule lora = 3;
inline bool Schedule::has_lora() const {
  return this != internal_default_instance() && lora_ != NULL;
}
inline void Schedule::clear_lora() {
  if (GetArenaNoVirtual() == NULL && lora_ != NULL) delete lora_;
  lora_ = NULL;
}
inline const ::fk_data::JobSchedule& Schedule::lora() const {
  const ::fk_data::JobSchedule* p = lora_;
  // @@protoc_insertion_point(field_get:fk_data.Schedule.lora)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::JobSchedule*>(
      &::fk_data::_JobSchedule_default_instance_);
}
inline ::fk_data::JobSchedule* Schedule::mutable_lora() {
  
  if (lora_ == NULL) {
    lora_ = new ::fk_data::JobSchedule;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.Schedule.lora)
  return lora_;
}
inline ::fk_data::JobSchedule* Schedule::release_lora() {
  // @@protoc_insertion_point(field_release:fk_data.Schedule.lora)
  
  ::fk_data::JobSchedule* temp = lora_;
  lora_ = NULL;
  return temp;
}
inline void Schedule::set_allocated_lora(::fk_data::JobSchedule* lora) {
  delete lora_;
  lora_ = lora;
  if (lora) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.Schedule.lora)
}

// .fk_data.JobSchedule gps = 4;
inline bool Schedule::has_gps() const {
  return this != internal_default_instance() && gps_ != NULL;
}
inline void Schedule::clear_gps() {
  if (GetArenaNoVirtual() == NULL && gps_ != NULL) delete gps_;
  gps_ = NULL;
}
inline const ::fk_data::JobSchedule& Schedule::gps() const {
  const ::fk_data::JobSchedule* p = gps_;
  // @@protoc_insertion_point(field_get:fk_data.Schedule.gps)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::JobSchedule*>(
      &::fk_data::_JobSchedule_default_instance_);
}
inline ::fk_data::JobSchedule* Schedule::mutable_gps() {
  
  if (gps_ == NULL) {
    gps_ = new ::fk_data::JobSchedule;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.Schedule.gps)
  return gps_;
}
inline ::fk_data::JobSchedule* Schedule::release_gps() {
  // @@protoc_insertion_point(field_release:fk_data.Schedule.gps)
  
  ::fk_data::JobSchedule* temp = gps_;
  gps_ = NULL;
  return temp;
}
inline void Schedule::set_allocated_gps(::fk_data::JobSchedule* gps) {
  delete gps_;
  gps_ = gps;
  if (gps) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.Schedule.gps)
}

// -------------------------------------------------------------------

// Identity

// string name = 1;
inline void Identity::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Identity::name() const {
  // @@protoc_insertion_point(field_get:fk_data.Identity.name)
  return name_.GetNoArena();
}
inline void Identity::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.Identity.name)
}
#if LANG_CXX11
inline void Identity::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.Identity.name)
}
#endif
inline void Identity::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.Identity.name)
}
inline void Identity::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.Identity.name)
}
inline ::std::string* Identity::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.Identity.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Identity::release_name() {
  // @@protoc_insertion_point(field_release:fk_data.Identity.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Identity::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:fk_data.Identity.name)
}

// -------------------------------------------------------------------

// Condition

// uint32 flags = 1;
inline void Condition::clear_flags() {
  flags_ = 0u;
}
inline ::google::protobuf::uint32 Condition::flags() const {
  // @@protoc_insertion_point(field_get:fk_data.Condition.flags)
  return flags_;
}
inline void Condition::set_flags(::google::protobuf::uint32 value) {
  
  flags_ = value;
  // @@protoc_insertion_point(field_set:fk_data.Condition.flags)
}

// uint32 recording = 2;
inline void Condition::clear_recording() {
  recording_ = 0u;
}
inline ::google::protobuf::uint32 Condition::recording() const {
  // @@protoc_insertion_point(field_get:fk_data.Condition.recording)
  return recording_;
}
inline void Condition::set_recording(::google::protobuf::uint32 value) {
  
  recording_ = value;
  // @@protoc_insertion_point(field_set:fk_data.Condition.recording)
}

// -------------------------------------------------------------------

// NetworkInfo

// string ssid = 1;
inline void NetworkInfo::clear_ssid() {
  ssid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkInfo::ssid() const {
  // @@protoc_insertion_point(field_get:fk_data.NetworkInfo.ssid)
  return ssid_.GetNoArena();
}
inline void NetworkInfo::set_ssid(const ::std::string& value) {
  
  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.NetworkInfo.ssid)
}
#if LANG_CXX11
inline void NetworkInfo::set_ssid(::std::string&& value) {
  
  ssid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.NetworkInfo.ssid)
}
#endif
inline void NetworkInfo::set_ssid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.NetworkInfo.ssid)
}
inline void NetworkInfo::set_ssid(const char* value, size_t size) {
  
  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.NetworkInfo.ssid)
}
inline ::std::string* NetworkInfo::mutable_ssid() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.NetworkInfo.ssid)
  return ssid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkInfo::release_ssid() {
  // @@protoc_insertion_point(field_release:fk_data.NetworkInfo.ssid)
  
  return ssid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkInfo::set_allocated_ssid(::std::string* ssid) {
  if (ssid != NULL) {
    
  } else {
    
  }
  ssid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ssid);
  // @@protoc_insertion_point(field_set_allocated:fk_data.NetworkInfo.ssid)
}

// string password = 2;
inline void NetworkInfo::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkInfo::password() const {
  // @@protoc_insertion_point(field_get:fk_data.NetworkInfo.password)
  return password_.GetNoArena();
}
inline void NetworkInfo::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.NetworkInfo.password)
}
#if LANG_CXX11
inline void NetworkInfo::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.NetworkInfo.password)
}
#endif
inline void NetworkInfo::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.NetworkInfo.password)
}
inline void NetworkInfo::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.NetworkInfo.password)
}
inline ::std::string* NetworkInfo::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.NetworkInfo.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkInfo::release_password() {
  // @@protoc_insertion_point(field_release:fk_data.NetworkInfo.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkInfo::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:fk_data.NetworkInfo.password)
}

// -------------------------------------------------------------------

// NetworkSettings

// repeated .fk_data.NetworkInfo networks = 1;
inline int NetworkSettings::networks_size() const {
  return networks_.size();
}
inline void NetworkSettings::clear_networks() {
  networks_.Clear();
}
inline const ::fk_data::NetworkInfo& NetworkSettings::networks(int index) const {
  // @@protoc_insertion_point(field_get:fk_data.NetworkSettings.networks)
  return networks_.Get(index);
}
inline ::fk_data::NetworkInfo* NetworkSettings::mutable_networks(int index) {
  // @@protoc_insertion_point(field_mutable:fk_data.NetworkSettings.networks)
  return networks_.Mutable(index);
}
inline ::fk_data::NetworkInfo* NetworkSettings::add_networks() {
  // @@protoc_insertion_point(field_add:fk_data.NetworkSettings.networks)
  return networks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fk_data::NetworkInfo >*
NetworkSettings::mutable_networks() {
  // @@protoc_insertion_point(field_mutable_list:fk_data.NetworkSettings.networks)
  return &networks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fk_data::NetworkInfo >&
NetworkSettings::networks() const {
  // @@protoc_insertion_point(field_list:fk_data.NetworkSettings.networks)
  return networks_;
}

// -------------------------------------------------------------------

// LoraSettings

// bytes deviceEui = 1;
inline void LoraSettings::clear_deviceeui() {
  deviceeui_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoraSettings::deviceeui() const {
  // @@protoc_insertion_point(field_get:fk_data.LoraSettings.deviceEui)
  return deviceeui_.GetNoArena();
}
inline void LoraSettings::set_deviceeui(const ::std::string& value) {
  
  deviceeui_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.LoraSettings.deviceEui)
}
#if LANG_CXX11
inline void LoraSettings::set_deviceeui(::std::string&& value) {
  
  deviceeui_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.LoraSettings.deviceEui)
}
#endif
inline void LoraSettings::set_deviceeui(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  deviceeui_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.LoraSettings.deviceEui)
}
inline void LoraSettings::set_deviceeui(const void* value, size_t size) {
  
  deviceeui_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.LoraSettings.deviceEui)
}
inline ::std::string* LoraSettings::mutable_deviceeui() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.LoraSettings.deviceEui)
  return deviceeui_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoraSettings::release_deviceeui() {
  // @@protoc_insertion_point(field_release:fk_data.LoraSettings.deviceEui)
  
  return deviceeui_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoraSettings::set_allocated_deviceeui(::std::string* deviceeui) {
  if (deviceeui != NULL) {
    
  } else {
    
  }
  deviceeui_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), deviceeui);
  // @@protoc_insertion_point(field_set_allocated:fk_data.LoraSettings.deviceEui)
}

// bytes appKey = 2;
inline void LoraSettings::clear_appkey() {
  appkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoraSettings::appkey() const {
  // @@protoc_insertion_point(field_get:fk_data.LoraSettings.appKey)
  return appkey_.GetNoArena();
}
inline void LoraSettings::set_appkey(const ::std::string& value) {
  
  appkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.LoraSettings.appKey)
}
#if LANG_CXX11
inline void LoraSettings::set_appkey(::std::string&& value) {
  
  appkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.LoraSettings.appKey)
}
#endif
inline void LoraSettings::set_appkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  appkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.LoraSettings.appKey)
}
inline void LoraSettings::set_appkey(const void* value, size_t size) {
  
  appkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.LoraSettings.appKey)
}
inline ::std::string* LoraSettings::mutable_appkey() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.LoraSettings.appKey)
  return appkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoraSettings::release_appkey() {
  // @@protoc_insertion_point(field_release:fk_data.LoraSettings.appKey)
  
  return appkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoraSettings::set_allocated_appkey(::std::string* appkey) {
  if (appkey != NULL) {
    
  } else {
    
  }
  appkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), appkey);
  // @@protoc_insertion_point(field_set_allocated:fk_data.LoraSettings.appKey)
}

// bytes appEui = 3;
inline void LoraSettings::clear_appeui() {
  appeui_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoraSettings::appeui() const {
  // @@protoc_insertion_point(field_get:fk_data.LoraSettings.appEui)
  return appeui_.GetNoArena();
}
inline void LoraSettings::set_appeui(const ::std::string& value) {
  
  appeui_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.LoraSettings.appEui)
}
#if LANG_CXX11
inline void LoraSettings::set_appeui(::std::string&& value) {
  
  appeui_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.LoraSettings.appEui)
}
#endif
inline void LoraSettings::set_appeui(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  appeui_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.LoraSettings.appEui)
}
inline void LoraSettings::set_appeui(const void* value, size_t size) {
  
  appeui_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.LoraSettings.appEui)
}
inline ::std::string* LoraSettings::mutable_appeui() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.LoraSettings.appEui)
  return appeui_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoraSettings::release_appeui() {
  // @@protoc_insertion_point(field_release:fk_data.LoraSettings.appEui)
  
  return appeui_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoraSettings::set_allocated_appeui(::std::string* appeui) {
  if (appeui != NULL) {
    
  } else {
    
  }
  appeui_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), appeui);
  // @@protoc_insertion_point(field_set_allocated:fk_data.LoraSettings.appEui)
}

// uint32 frequencyBand = 4;
inline void LoraSettings::clear_frequencyband() {
  frequencyband_ = 0u;
}
inline ::google::protobuf::uint32 LoraSettings::frequencyband() const {
  // @@protoc_insertion_point(field_get:fk_data.LoraSettings.frequencyBand)
  return frequencyband_;
}
inline void LoraSettings::set_frequencyband(::google::protobuf::uint32 value) {
  
  frequencyband_ = value;
  // @@protoc_insertion_point(field_set:fk_data.LoraSettings.frequencyBand)
}

// -------------------------------------------------------------------

// DataRecord

// .fk_data.LoggedReading loggedReading = 1;
inline bool DataRecord::has_loggedreading() const {
  return this != internal_default_instance() && loggedreading_ != NULL;
}
inline void DataRecord::clear_loggedreading() {
  if (GetArenaNoVirtual() == NULL && loggedreading_ != NULL) delete loggedreading_;
  loggedreading_ = NULL;
}
inline const ::fk_data::LoggedReading& DataRecord::loggedreading() const {
  const ::fk_data::LoggedReading* p = loggedreading_;
  // @@protoc_insertion_point(field_get:fk_data.DataRecord.loggedReading)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::LoggedReading*>(
      &::fk_data::_LoggedReading_default_instance_);
}
inline ::fk_data::LoggedReading* DataRecord::mutable_loggedreading() {
  
  if (loggedreading_ == NULL) {
    loggedreading_ = new ::fk_data::LoggedReading;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.DataRecord.loggedReading)
  return loggedreading_;
}
inline ::fk_data::LoggedReading* DataRecord::release_loggedreading() {
  // @@protoc_insertion_point(field_release:fk_data.DataRecord.loggedReading)
  
  ::fk_data::LoggedReading* temp = loggedreading_;
  loggedreading_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_loggedreading(::fk_data::LoggedReading* loggedreading) {
  delete loggedreading_;
  loggedreading_ = loggedreading;
  if (loggedreading) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.DataRecord.loggedReading)
}

// .fk_data.Metadata metadata = 2;
inline bool DataRecord::has_metadata() const {
  return this != internal_default_instance() && metadata_ != NULL;
}
inline void DataRecord::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) delete metadata_;
  metadata_ = NULL;
}
inline const ::fk_data::Metadata& DataRecord::metadata() const {
  const ::fk_data::Metadata* p = metadata_;
  // @@protoc_insertion_point(field_get:fk_data.DataRecord.metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::Metadata*>(
      &::fk_data::_Metadata_default_instance_);
}
inline ::fk_data::Metadata* DataRecord::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::fk_data::Metadata;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.DataRecord.metadata)
  return metadata_;
}
inline ::fk_data::Metadata* DataRecord::release_metadata() {
  // @@protoc_insertion_point(field_release:fk_data.DataRecord.metadata)
  
  ::fk_data::Metadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_metadata(::fk_data::Metadata* metadata) {
  delete metadata_;
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.DataRecord.metadata)
}

// .fk_data.LogMessage log = 3;
inline bool DataRecord::has_log() const {
  return this != internal_default_instance() && log_ != NULL;
}
inline void DataRecord::clear_log() {
  if (GetArenaNoVirtual() == NULL && log_ != NULL) delete log_;
  log_ = NULL;
}
inline const ::fk_data::LogMessage& DataRecord::log() const {
  const ::fk_data::LogMessage* p = log_;
  // @@protoc_insertion_point(field_get:fk_data.DataRecord.log)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::LogMessage*>(
      &::fk_data::_LogMessage_default_instance_);
}
inline ::fk_data::LogMessage* DataRecord::mutable_log() {
  
  if (log_ == NULL) {
    log_ = new ::fk_data::LogMessage;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.DataRecord.log)
  return log_;
}
inline ::fk_data::LogMessage* DataRecord::release_log() {
  // @@protoc_insertion_point(field_release:fk_data.DataRecord.log)
  
  ::fk_data::LogMessage* temp = log_;
  log_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_log(::fk_data::LogMessage* log) {
  delete log_;
  log_ = log;
  if (log) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.DataRecord.log)
}

// .fk_data.Status status = 4;
inline bool DataRecord::has_status() const {
  return this != internal_default_instance() && status_ != NULL;
}
inline void DataRecord::clear_status() {
  if (GetArenaNoVirtual() == NULL && status_ != NULL) delete status_;
  status_ = NULL;
}
inline const ::fk_data::Status& DataRecord::status() const {
  const ::fk_data::Status* p = status_;
  // @@protoc_insertion_point(field_get:fk_data.DataRecord.status)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::Status*>(
      &::fk_data::_Status_default_instance_);
}
inline ::fk_data::Status* DataRecord::mutable_status() {
  
  if (status_ == NULL) {
    status_ = new ::fk_data::Status;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.DataRecord.status)
  return status_;
}
inline ::fk_data::Status* DataRecord::release_status() {
  // @@protoc_insertion_point(field_release:fk_data.DataRecord.status)
  
  ::fk_data::Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_status(::fk_data::Status* status) {
  delete status_;
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.DataRecord.status)
}

// .fk_data.Readings readings = 5;
inline bool DataRecord::has_readings() const {
  return this != internal_default_instance() && readings_ != NULL;
}
inline void DataRecord::clear_readings() {
  if (GetArenaNoVirtual() == NULL && readings_ != NULL) delete readings_;
  readings_ = NULL;
}
inline const ::fk_data::Readings& DataRecord::readings() const {
  const ::fk_data::Readings* p = readings_;
  // @@protoc_insertion_point(field_get:fk_data.DataRecord.readings)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::Readings*>(
      &::fk_data::_Readings_default_instance_);
}
inline ::fk_data::Readings* DataRecord::mutable_readings() {
  
  if (readings_ == NULL) {
    readings_ = new ::fk_data::Readings;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.DataRecord.readings)
  return readings_;
}
inline ::fk_data::Readings* DataRecord::release_readings() {
  // @@protoc_insertion_point(field_release:fk_data.DataRecord.readings)
  
  ::fk_data::Readings* temp = readings_;
  readings_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_readings(::fk_data::Readings* readings) {
  delete readings_;
  readings_ = readings;
  if (readings) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.DataRecord.readings)
}

// repeated .fk_data.ModuleInfo modules = 6;
inline int DataRecord::modules_size() const {
  return modules_.size();
}
inline void DataRecord::clear_modules() {
  modules_.Clear();
}
inline const ::fk_data::ModuleInfo& DataRecord::modules(int index) const {
  // @@protoc_insertion_point(field_get:fk_data.DataRecord.modules)
  return modules_.Get(index);
}
inline ::fk_data::ModuleInfo* DataRecord::mutable_modules(int index) {
  // @@protoc_insertion_point(field_mutable:fk_data.DataRecord.modules)
  return modules_.Mutable(index);
}
inline ::fk_data::ModuleInfo* DataRecord::add_modules() {
  // @@protoc_insertion_point(field_add:fk_data.DataRecord.modules)
  return modules_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fk_data::ModuleInfo >*
DataRecord::mutable_modules() {
  // @@protoc_insertion_point(field_mutable_list:fk_data.DataRecord.modules)
  return &modules_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fk_data::ModuleInfo >&
DataRecord::modules() const {
  // @@protoc_insertion_point(field_list:fk_data.DataRecord.modules)
  return modules_;
}

// .fk_data.Schedule schedule = 7;
inline bool DataRecord::has_schedule() const {
  return this != internal_default_instance() && schedule_ != NULL;
}
inline void DataRecord::clear_schedule() {
  if (GetArenaNoVirtual() == NULL && schedule_ != NULL) delete schedule_;
  schedule_ = NULL;
}
inline const ::fk_data::Schedule& DataRecord::schedule() const {
  const ::fk_data::Schedule* p = schedule_;
  // @@protoc_insertion_point(field_get:fk_data.DataRecord.schedule)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::Schedule*>(
      &::fk_data::_Schedule_default_instance_);
}
inline ::fk_data::Schedule* DataRecord::mutable_schedule() {
  
  if (schedule_ == NULL) {
    schedule_ = new ::fk_data::Schedule;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.DataRecord.schedule)
  return schedule_;
}
inline ::fk_data::Schedule* DataRecord::release_schedule() {
  // @@protoc_insertion_point(field_release:fk_data.DataRecord.schedule)
  
  ::fk_data::Schedule* temp = schedule_;
  schedule_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_schedule(::fk_data::Schedule* schedule) {
  delete schedule_;
  schedule_ = schedule;
  if (schedule) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.DataRecord.schedule)
}

// uint64 meta = 8;
inline void DataRecord::clear_meta() {
  meta_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 DataRecord::meta() const {
  // @@protoc_insertion_point(field_get:fk_data.DataRecord.meta)
  return meta_;
}
inline void DataRecord::set_meta(::google::protobuf::uint64 value) {
  
  meta_ = value;
  // @@protoc_insertion_point(field_set:fk_data.DataRecord.meta)
}

// .fk_data.Identity identity = 9;
inline bool DataRecord::has_identity() const {
  return this != internal_default_instance() && identity_ != NULL;
}
inline void DataRecord::clear_identity() {
  if (GetArenaNoVirtual() == NULL && identity_ != NULL) delete identity_;
  identity_ = NULL;
}
inline const ::fk_data::Identity& DataRecord::identity() const {
  const ::fk_data::Identity* p = identity_;
  // @@protoc_insertion_point(field_get:fk_data.DataRecord.identity)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::Identity*>(
      &::fk_data::_Identity_default_instance_);
}
inline ::fk_data::Identity* DataRecord::mutable_identity() {
  
  if (identity_ == NULL) {
    identity_ = new ::fk_data::Identity;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.DataRecord.identity)
  return identity_;
}
inline ::fk_data::Identity* DataRecord::release_identity() {
  // @@protoc_insertion_point(field_release:fk_data.DataRecord.identity)
  
  ::fk_data::Identity* temp = identity_;
  identity_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_identity(::fk_data::Identity* identity) {
  delete identity_;
  identity_ = identity;
  if (identity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.DataRecord.identity)
}

// .fk_data.Condition condition = 10;
inline bool DataRecord::has_condition() const {
  return this != internal_default_instance() && condition_ != NULL;
}
inline void DataRecord::clear_condition() {
  if (GetArenaNoVirtual() == NULL && condition_ != NULL) delete condition_;
  condition_ = NULL;
}
inline const ::fk_data::Condition& DataRecord::condition() const {
  const ::fk_data::Condition* p = condition_;
  // @@protoc_insertion_point(field_get:fk_data.DataRecord.condition)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::Condition*>(
      &::fk_data::_Condition_default_instance_);
}
inline ::fk_data::Condition* DataRecord::mutable_condition() {
  
  if (condition_ == NULL) {
    condition_ = new ::fk_data::Condition;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.DataRecord.condition)
  return condition_;
}
inline ::fk_data::Condition* DataRecord::release_condition() {
  // @@protoc_insertion_point(field_release:fk_data.DataRecord.condition)
  
  ::fk_data::Condition* temp = condition_;
  condition_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_condition(::fk_data::Condition* condition) {
  delete condition_;
  condition_ = condition;
  if (condition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.DataRecord.condition)
}

// .fk_data.LoraSettings lora = 11;
inline bool DataRecord::has_lora() const {
  return this != internal_default_instance() && lora_ != NULL;
}
inline void DataRecord::clear_lora() {
  if (GetArenaNoVirtual() == NULL && lora_ != NULL) delete lora_;
  lora_ = NULL;
}
inline const ::fk_data::LoraSettings& DataRecord::lora() const {
  const ::fk_data::LoraSettings* p = lora_;
  // @@protoc_insertion_point(field_get:fk_data.DataRecord.lora)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::LoraSettings*>(
      &::fk_data::_LoraSettings_default_instance_);
}
inline ::fk_data::LoraSettings* DataRecord::mutable_lora() {
  
  if (lora_ == NULL) {
    lora_ = new ::fk_data::LoraSettings;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.DataRecord.lora)
  return lora_;
}
inline ::fk_data::LoraSettings* DataRecord::release_lora() {
  // @@protoc_insertion_point(field_release:fk_data.DataRecord.lora)
  
  ::fk_data::LoraSettings* temp = lora_;
  lora_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_lora(::fk_data::LoraSettings* lora) {
  delete lora_;
  lora_ = lora;
  if (lora) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.DataRecord.lora)
}

// .fk_data.NetworkSettings network = 12;
inline bool DataRecord::has_network() const {
  return this != internal_default_instance() && network_ != NULL;
}
inline void DataRecord::clear_network() {
  if (GetArenaNoVirtual() == NULL && network_ != NULL) delete network_;
  network_ = NULL;
}
inline const ::fk_data::NetworkSettings& DataRecord::network() const {
  const ::fk_data::NetworkSettings* p = network_;
  // @@protoc_insertion_point(field_get:fk_data.DataRecord.network)
  return p != NULL ? *p : *reinterpret_cast<const ::fk_data::NetworkSettings*>(
      &::fk_data::_NetworkSettings_default_instance_);
}
inline ::fk_data::NetworkSettings* DataRecord::mutable_network() {
  
  if (network_ == NULL) {
    network_ = new ::fk_data::NetworkSettings;
  }
  // @@protoc_insertion_point(field_mutable:fk_data.DataRecord.network)
  return network_;
}
inline ::fk_data::NetworkSettings* DataRecord::release_network() {
  // @@protoc_insertion_point(field_release:fk_data.DataRecord.network)
  
  ::fk_data::NetworkSettings* temp = network_;
  network_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_network(::fk_data::NetworkSettings* network) {
  delete network_;
  network_ = network;
  if (network) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:fk_data.DataRecord.network)
}

// -------------------------------------------------------------------

// SignedRecord

// .fk_data.SignedRecordKind kind = 1;
inline void SignedRecord::clear_kind() {
  kind_ = 0;
}
inline ::fk_data::SignedRecordKind SignedRecord::kind() const {
  // @@protoc_insertion_point(field_get:fk_data.SignedRecord.kind)
  return static_cast< ::fk_data::SignedRecordKind >(kind_);
}
inline void SignedRecord::set_kind(::fk_data::SignedRecordKind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:fk_data.SignedRecord.kind)
}

// uint64 time = 2;
inline void SignedRecord::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SignedRecord::time() const {
  // @@protoc_insertion_point(field_get:fk_data.SignedRecord.time)
  return time_;
}
inline void SignedRecord::set_time(::google::protobuf::uint64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:fk_data.SignedRecord.time)
}

// bytes data = 3;
inline void SignedRecord::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SignedRecord::data() const {
  // @@protoc_insertion_point(field_get:fk_data.SignedRecord.data)
  return data_.GetNoArena();
}
inline void SignedRecord::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.SignedRecord.data)
}
#if LANG_CXX11
inline void SignedRecord::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.SignedRecord.data)
}
#endif
inline void SignedRecord::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.SignedRecord.data)
}
inline void SignedRecord::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.SignedRecord.data)
}
inline ::std::string* SignedRecord::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.SignedRecord.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignedRecord::release_data() {
  // @@protoc_insertion_point(field_release:fk_data.SignedRecord.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignedRecord::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:fk_data.SignedRecord.data)
}

// bytes hash = 4;
inline void SignedRecord::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SignedRecord::hash() const {
  // @@protoc_insertion_point(field_get:fk_data.SignedRecord.hash)
  return hash_.GetNoArena();
}
inline void SignedRecord::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.SignedRecord.hash)
}
#if LANG_CXX11
inline void SignedRecord::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.SignedRecord.hash)
}
#endif
inline void SignedRecord::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.SignedRecord.hash)
}
inline void SignedRecord::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.SignedRecord.hash)
}
inline ::std::string* SignedRecord::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.SignedRecord.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignedRecord::release_hash() {
  // @@protoc_insertion_point(field_release:fk_data.SignedRecord.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignedRecord::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:fk_data.SignedRecord.hash)
}

// uint64 record = 5;
inline void SignedRecord::clear_record() {
  record_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SignedRecord::record() const {
  // @@protoc_insertion_point(field_get:fk_data.SignedRecord.record)
  return record_;
}
inline void SignedRecord::set_record(::google::protobuf::uint64 value) {
  
  record_ = value;
  // @@protoc_insertion_point(field_set:fk_data.SignedRecord.record)
}

// -------------------------------------------------------------------

// LoraRecord

// bytes deviceId = 1;
inline void LoraRecord::clear_deviceid() {
  deviceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoraRecord::deviceid() const {
  // @@protoc_insertion_point(field_get:fk_data.LoraRecord.deviceId)
  return deviceid_.GetNoArena();
}
inline void LoraRecord::set_deviceid(const ::std::string& value) {
  
  deviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.LoraRecord.deviceId)
}
#if LANG_CXX11
inline void LoraRecord::set_deviceid(::std::string&& value) {
  
  deviceid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.LoraRecord.deviceId)
}
#endif
inline void LoraRecord::set_deviceid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  deviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.LoraRecord.deviceId)
}
inline void LoraRecord::set_deviceid(const void* value, size_t size) {
  
  deviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.LoraRecord.deviceId)
}
inline ::std::string* LoraRecord::mutable_deviceid() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.LoraRecord.deviceId)
  return deviceid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoraRecord::release_deviceid() {
  // @@protoc_insertion_point(field_release:fk_data.LoraRecord.deviceId)
  
  return deviceid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoraRecord::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid != NULL) {
    
  } else {
    
  }
  deviceid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), deviceid);
  // @@protoc_insertion_point(field_set_allocated:fk_data.LoraRecord.deviceId)
}

// uint64 time = 2;
inline void LoraRecord::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 LoraRecord::time() const {
  // @@protoc_insertion_point(field_get:fk_data.LoraRecord.time)
  return time_;
}
inline void LoraRecord::set_time(::google::protobuf::uint64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:fk_data.LoraRecord.time)
}

// uint64 number = 3;
inline void LoraRecord::clear_number() {
  number_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 LoraRecord::number() const {
  // @@protoc_insertion_point(field_get:fk_data.LoraRecord.number)
  return number_;
}
inline void LoraRecord::set_number(::google::protobuf::uint64 value) {
  
  number_ = value;
  // @@protoc_insertion_point(field_set:fk_data.LoraRecord.number)
}

// uint32 module = 4;
inline void LoraRecord::clear_module() {
  module_ = 0u;
}
inline ::google::protobuf::uint32 LoraRecord::module() const {
  // @@protoc_insertion_point(field_get:fk_data.LoraRecord.module)
  return module_;
}
inline void LoraRecord::set_module(::google::protobuf::uint32 value) {
  
  module_ = value;
  // @@protoc_insertion_point(field_set:fk_data.LoraRecord.module)
}

// uint64 sensor = 5;
inline void LoraRecord::clear_sensor() {
  sensor_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 LoraRecord::sensor() const {
  // @@protoc_insertion_point(field_get:fk_data.LoraRecord.sensor)
  return sensor_;
}
inline void LoraRecord::set_sensor(::google::protobuf::uint64 value) {
  
  sensor_ = value;
  // @@protoc_insertion_point(field_set:fk_data.LoraRecord.sensor)
}

// repeated float values = 6;
inline int LoraRecord::values_size() const {
  return values_.size();
}
inline void LoraRecord::clear_values() {
  values_.Clear();
}
inline float LoraRecord::values(int index) const {
  // @@protoc_insertion_point(field_get:fk_data.LoraRecord.values)
  return values_.Get(index);
}
inline void LoraRecord::set_values(int index, float value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:fk_data.LoraRecord.values)
}
inline void LoraRecord::add_values(float value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:fk_data.LoraRecord.values)
}
inline const ::google::protobuf::RepeatedField< float >&
LoraRecord::values() const {
  // @@protoc_insertion_point(field_list:fk_data.LoraRecord.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< float >*
LoraRecord::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:fk_data.LoraRecord.values)
  return &values_;
}

// bytes data = 7;
inline void LoraRecord::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoraRecord::data() const {
  // @@protoc_insertion_point(field_get:fk_data.LoraRecord.data)
  return data_.GetNoArena();
}
inline void LoraRecord::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fk_data.LoraRecord.data)
}
#if LANG_CXX11
inline void LoraRecord::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fk_data.LoraRecord.data)
}
#endif
inline void LoraRecord::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fk_data.LoraRecord.data)
}
inline void LoraRecord::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fk_data.LoraRecord.data)
}
inline ::std::string* LoraRecord::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:fk_data.LoraRecord.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoraRecord::release_data() {
  // @@protoc_insertion_point(field_release:fk_data.LoraRecord.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoraRecord::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:fk_data.LoraRecord.data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace fk_data

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::fk_data::DownloadFlags> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fk_data::DownloadFlags>() {
  return ::fk_data::DownloadFlags_descriptor();
}
template <> struct is_proto_enum< ::fk_data::ConditionFlags> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fk_data::ConditionFlags>() {
  return ::fk_data::ConditionFlags_descriptor();
}
template <> struct is_proto_enum< ::fk_data::SignedRecordKind> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fk_data::SignedRecordKind>() {
  return ::fk_data::SignedRecordKind_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_fk_2ddata_2eproto__INCLUDED
